<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Grunt | zziuni's Blog]]></title>
  <link href="http://zziuni.github.io/blog/categories/grunt/atom.xml" rel="self"/>
  <link href="http://zziuni.github.io/"/>
  <updated>2013-12-17T18:23:05+09:00</updated>
  <id>http://zziuni.github.io/</id>
  <author>
    <name><![CDATA[zziuni]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gruntjs.com을 우리말로 번역했습니다.]]></title>
    <link href="http://zziuni.github.io/blog/2013/12/17/gruntjs-dot-com-translated-to-korean/"/>
    <updated>2013-12-17T17:35:00+09:00</updated>
    <id>http://zziuni.github.io/blog/2013/12/17/gruntjs-dot-com-translated-to-korean</id>
    <content type="html"><![CDATA[<p>Grunt 문서 몇 개를 번역해서 올리다가.. Gruntjs Repo를 확인해보니 사이트와 사이트 콘텐츠도 Github으로 관리되고 있길래, 포크(<a href="https://github.com/zziuni/gruntjs.com">gruntjs.com</a>, <a href="https://github.com/zziuni/grunt-docs">grunt-docs</a>) 받아서 그리로 통합했습니다.
이제 <strong>Grunt 사이트는 한글로 <a href="http://gurntjs-kr.herokuapp.com/">http://gurntjs-kr.herokuapp.com/</a>에서 볼 수 있습니다.</strong></p>

<p>첨에 신나서 배포하다가 오타(gurnt)낸 걸 알고, 소심해서 얼른 올바른 주소(?)를 하나 더 배포했습니다.</p>

<p>그냥 순서대로 번역 중입니다. 중요한 건 다 번역 듯하지만 아직 번역 안 된 문서는 짬짬이 번역해 올릴 겁니다. 오타나 번역오류를 찾으면 <a href="https://github.com/zziuni/grunt-docs/issues">Github Issues</a>에 올려주세요.</p>

<p>국내에서도 Grunt를 좀 더 많이 썼으면 좋겠네요.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt: Create tasks in korean]]></title>
    <link href="http://zziuni.github.io/blog/2013/12/01/grunt-create-tasks-in-korean/"/>
    <updated>2013-12-01T12:11:00+09:00</updated>
    <id>http://zziuni.github.io/blog/2013/12/01/grunt-create-tasks-in-korean</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://zziuni.pe.kr">Grunt</a>은 Javascript Task Runner 입니다.. 이 문서는 Grunt 공식 사이트의 <a href="http://gruntjs.com/creating-tasks">Create tasks</a>를 번역한 문서이며 grunt-cli의 버전이 0.1.11일 때 번역했습니다.</p></blockquote>

<h1>Create tasks</h1>

<p>Task는 Grunt의 존재 이유이자 가장 중요한 개념이다. 여러분이 하는 대부분의 일(task)은 <code>jshint</code>나 <code>nodeunit</code>같은 것들이다. 실행할 Task를 하나 이상 명시해서 Grunt에게 하고 싶은 일이 무엇인지 알려주면, Grunt가 그 일을 매번 실행한다.</p>

<p>여러분이 task를 새로 명시하지 않았고, &ldquo;default"란 이름의 task가 이미 정의되어 있다면, 기본값으로 그 task가 실행된다.</p>

<!-- more -->


<h2>Alias Tasks</h2>

<p>다음처럼 새로운 task에 다른 task 명단을 명시하면, 그 신규 task의 이름은 여러 task들을 대표하는 별명(alias)이 된다. 이런 &ldquo;alias task"가 실행될 때면, <code>taskList</code>에 명시한 모든 task들이 순서대로 실행된다. 이때 <code>taskList</code> 전달인자는 배열이다.</p>

<p><code>javascript
grunt.registerTask(taskName, [description, ] taskList)
</code></p>

<p>다음 예제는 Grunt를 특정 task 지정없이 <code>grunt</code>로 실행할 때 자동으로 &ldquo;jshint&rdquo;, &ldquo;qunit&rdquo;, &ldquo;concat&rdquo;, &ldquo;uglify&rdquo; task들을 실행하는 &ldquo;default"라는 alias task다.</p>

<p><code>javascript
grunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']);
</code></p>

<p>Task 전달인자를 다음처럼 지정할 수도 있다. &ldquo;dist"라는 alias task는 "concat"과 "uglify"에서 "dist&rdquo; target 들만 실행한다.</p>

<p><code>javascript
grunt.registerTask('dist', ['concat:dist', 'uglify:dist']);
</code></p>

<h2>Multi Tasks</h2>

<p>Multi-task로 만든 task는 실행될 때, Grunt 환경 설정 객체에서 동명의 프로퍼티를 찾는다. 또한 multi-task는 적절한 target(task의 하위 개념) 명으로 각자의 환경설정을 가질 수 있다.</p>

<p><code>grunt concat</code>란 컴멘드가 그 안의 모든 target를 순회하는 반면에, <code>grunt concat:foo</code>나 <code>grunt concat:bar</code>처럼 task와 target까지 지정하면, 특정 target의 환경설정만 가져온다. 이때  <a href="http://gruntjs.com/grunt.task#grunt.task.renametask">grunt.task.renameTask</a>로 이름을 변경하면, 바꾼 task 명으로 환경 설정을 찾는다.</p>

<p><a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint plugin jshint task</a>와 <a href="https://github.com/gruntjs/grunt-contrib-concat">grunt-contrib-concat plugin concat task</a>같이 contrib로 시작하는 대부분의 task는 multi task다.</p>

<p><code>javascript
grunt.registerMultiTask(taskName, [description, ] taskFunction)
</code></p>

<p>다음 multi-task에서 <code>grunt log:foo</code>로 grunt를 실행하면 <code>foo: 1,2,3</code>가 로그로 찍히고, <code>grunt log:bar</code>로 grunt를 실행하면 <code>bar: hello world</code>가 찍힌다. 하지만 <code>grunt log</code>로 grunt를 실행하면 순서대로 <code>foo: 1,2,3</code>가 찍히고 <code>bar: hello world</code>가 찍힌 다음 <code>baz: false</code>가 찍힌다.</p>

<p>```javascript
grunt.initConfig({
  log: {</p>

<pre><code>foo: [1, 2, 3],
bar: 'hello world',
baz: false
</code></pre>

<p>  }
});</p>

<p>grunt.registerMultiTask(&lsquo;log&rsquo;, &lsquo;Log stuff.&rsquo;, function() {
  grunt.log.writeln(this.target + &lsquo;: &rsquo; + this.data);
});
```</p>

<h2>&ldquo;Basic&rdquo; Tasks</h2>

<p>Multi-task가 아닌 기본 task가 실행될 때는 Grunt가 환경설정을 바라보지 않는다. 지정한 task function만 실행한다. 기본 task에서는 콜론(:)로 구분한 인자 목록을 task function 함수의 전달인자로 넘길 수 있다.</p>

<p><code>javascript
grunt.registerTask(taskName, [description, ] taskFunction)
</code></p>

<p><code>grunt foo:testing:123</code>를 입력하면 <code>foo, testing 123</code>가 콘솔에 출력된다. <code>grunt foo</code>처럼 아무 인자도 넘기지 않고 실행하면 <code>foo, no args</code>가 콘솔에 찍힌다.</p>

<p>```javascript
grunt.registerTask(&lsquo;foo&rsquo;, &lsquo;A sample task that logs stuff.&rsquo;, function(arg1, arg2) {
  if (arguments.length === 0) {</p>

<pre><code>grunt.log.writeln(this.name + ", no args");
</code></pre>

<p>  } else {</p>

<pre><code>grunt.log.writeln(this.name + ", " + arg1 + " " + arg2);
</code></pre>

<p>  }
});
```</p>

<h2>Custom tasks</h2>

<p>만들려는 Task가 &ldquo;multi-task&rdquo; 구조를 따르지 않는다면 기본 task형태로 사용자 정의  task를 만들자.</p>

<p><code>javascript
grunt.registerTask('default', 'My "default" task description.', function() {
  grunt.log.writeln('Currently running the "default" task.');
});
</code></p>

<p>task 안에서 다른 task를 실행할 수 있으며,</p>

<p><code>javascript
grunt.registerTask('foo', 'My "foo" task.', function() {
  // "bar"와 "baz" task가 "foo" 가 끝난 후에 순서대로 실행하려고 대기중이다.
  grunt.task.run('bar', 'baz');
  // 이렇게 적어도 된다.
  grunt.task.run(['bar', 'baz']);
});
</code></p>

<p>비동기도 가능하다.</p>

<p>```javascript
grunt.registerTask(&lsquo;asyncfoo&rsquo;, &lsquo;My &ldquo;asyncfoo&rdquo; task.&rsquo;, function() {
  // task를 비동기 모드로 만들고 &ldquo;done&rdquo; 함수로 제어한다.
  var done = this.async();
  // 동기 작업을 실행한다.
  grunt.log.writeln(&lsquo;Processing task&hellip;&rsquo;);
  // 그리고 비동기 작업을 실행한다.
  setTimeout(function() {</p>

<pre><code>grunt.log.writeln('All done!');
done();
</code></pre>

<p>  }, 1000);
});
```</p>

<p>이렇게 만든 task도 그 이름과 인자를 사용해서 접근할 수 있다.</p>

<p>```javascript
grunt.registerTask(&lsquo;foo&rsquo;, &lsquo;My &ldquo;foo&rdquo; task.&rsquo;, function(a, b) {
  grunt.log.writeln(this.name, a, b);
});</p>

<p>// 사용법:
// grunt foo foo:bar
//   출력로그: &ldquo;foo&rdquo;, undefined, undefined
//   출력로그: &ldquo;foo&rdquo;, &ldquo;bar&rdquo;, undefined
// grunt foo:bar:baz
//   출력로그: &ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;
```</p>

<p>Task에서 에러가 발생하면 Task를 실패처리 할 수도 있다.</p>

<p>```javascript
grunt.registerTask(&lsquo;foo&rsquo;, &lsquo;My &ldquo;foo&rdquo; task.&rsquo;, function() {
  if (failureOfSomeKind) {</p>

<pre><code>grunt.log.error('에러 메세지');
</code></pre>

<p>  }</p>

<p>  // task 실행 중 에러가 있다면 false를 반환해서 실패 처리한다.
  if (ifErrors) { return false; }</p>

<p>  grunt.log.writeln(&lsquo;성공 메세지&rsquo;);
});
```</p>

<p>task가 실패하면, <code>--force</code>를 붙이지 않는한 그 이후 작업은 모두 중단된다.</p>

<p>```javascript
grunt.registerTask(&lsquo;foo&rsquo;, &lsquo;My &ldquo;foo&rdquo; task.&rsquo;, function() {
  // 동기적 실패 처리
  return false;
});</p>

<p>grunt.registerTask(&lsquo;bar&rsquo;, &lsquo;My &ldquo;bar&rdquo; task.&rsquo;, function() {
  var done = this.async();
  setTimeout(function() {</p>

<pre><code>// 비동기적 실패 처리
done(false);
</code></pre>

<p>  }, 1000);
});
```</p>

<p>Task는 다른 task가 성공적으로 실행되었는지 여부와 관련지을 수도 있다. <code>grunt.task.requires</code>는 실제로 다른 task를 실행하지는 않지만, 그 task가 실행되었는지, 실패는 없었는지를 확인한다.</p>

<p>```javascript
grunt.registerTask(&lsquo;foo&rsquo;, &lsquo;My &ldquo;foo&rdquo; task.&rsquo;, function() {
  return false;
});</p>

<p>grunt.registerTask(&lsquo;bar&rsquo;, &lsquo;My &ldquo;bar&rdquo; task.&rsquo;, function() {
  // &ldquo;foo&rdquo; task가 실패했거나 실행된적이 없다면, 이 task를 실패 처리한다.
  grunt.task.requires(&lsquo;foo&rsquo;);
  // 이 코드는 &ldquo;foo&rdquo; task가 성공적으로 실행된 적이 있을 때만 실행된다.
  grunt.log.writeln(&lsquo;Hello, world.&rsquo;);
});</p>

<p>// 사용법
// grunt foo bar
//   foo가 실패하는 task이므로 로그는 출력되지 않는다.
// grunt bar
//   foo가 실행된적이 없으므로 로그는 출력되지 않는다.
```</p>

<p><code>grunt.config.requires</code>를 사용하면, Task가 존재하지 않는 환경설정 프로퍼티를 요구할 때, 실패 처리할 수 있다.</p>

<p><code>javascript
grunt.registerTask('foo', 'My "foo" task.', function() {
  // "meta.name" 란 환경설정 프로퍼티가 없으면 이 타스트를 실패 처리한다.
  grunt.config.requires('meta.name');
  // 이경우도 "meta.name" 환경설정 프로퍼티가 없다면, 실패한다.
  grunt.config.requires(['meta', 'name']);
  // 조건이 충족되어야 로그가 출력된다.
  grunt.log.writeln('meta.name이 환경설정에 정의되어있을 때만 로그가 출력된다.');
});
</code></p>

<p>환경설정 프로퍼티에는 <code>grunt.config</code>로 접근할 수 있다.</p>

<p><code>javascript
grunt.registerTask('foo', 'My "foo" task.', function() {
  // 프로퍼티 값을 로그로 출력한다. 프로퍼티가 undefined이면 null을 반환한다.
  grunt.log.writeln('The meta.name property is: ' + grunt.config('meta.name'));
  // 이경우도 프로퍼티 값을 로그로 출력한다. 프로퍼티가 undefined이면 null을 반환한다.
  grunt.log.writeln('The meta.name property is: ' + grunt.config(['meta', 'name']));
});
</code></p>

<p>더 자세한 예제는 <a href="https://github.com/gruntjs/">contrib task</a>들을 참고하자.</p>

<h2>CLI optiosn / environment</h2>

<p>내용 없음.</p>

<h2>Why doesn&rsquo;t my asynchronous task complete?</h2>

<p>비동기 task를 짰는데 완료되지 않는다면, 대부분 <a href="http://gruntjs.com/grunt.task#wiki-this-async">this.asynce</a>를 호출하지 않았기 때문이다. 쉽게 하려면, 동기식 코딩 스타일을 사용하고 나서 task 내부에 <code>this.async()</code>를 호출해서 비동기로 변경할 수 있다.</p>

<p>그리고 다시 말하지만, <code>done()</code>에 인자로 <code>false</code>를 넘기면 Grunt에게 task가 실패했다고 알릴 수 있다.</p>

<p>예제 코드다.</p>

<p><code>javascript
grunt.registerTask('asyncme', 'My asynchronous task.', function() {
  var done = this.async();
  doSomethingAsync(done);
});
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt: Sample Gruntfile in korean]]></title>
    <link href="http://zziuni.github.io/blog/2013/11/26/grunt-sample-gruntfile-in-korean/"/>
    <updated>2013-11-26T00:31:00+09:00</updated>
    <id>http://zziuni.github.io/blog/2013/11/26/grunt-sample-gruntfile-in-korean</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://gruntjs.com">Grunt</a>은 Javascript Task Runner 입니다.. 이 문서는 Grunt 공식 사이트의 <a href="http://gruntjs.com/sample-gruntfile">Sample Gruntfile</a>를 번역한 문서이며 grunt-cli의 버전이 0.1.11일 때 번역했습니다.</p></blockquote>

<h1>Sample Gruntfile</h1>

<p>다음 다섯 개의 Grunt 플러그인을 사용하는 <code>Gruntfile</code> 샘플을 살펴보겠다.</p>

<ul>
<li><a href="https://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-qunit">grunt-contrib-qunit</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-concat">grunt-contrib-concat</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-watch">grunt-contrib-watch</a></li>
</ul>


<!-- more -->


<p>전체 <code>Gruntfile</code>은 이 페이지 가장 아래에 제공하지만, 순서대로 읽어야 단계별로 이해할 수 있다.</p>

<p>첫 부분은 Grunt 환경설정을 캡슐화하는 &ldquo;wrapper&rdquo; 함수다.</p>

<p><code>javascript
module.exports = function(grunt){
}
</code></p>

<p>이 함수안에서 환경설정 객체를 생성할 수 있다.</p>

<p><code>javascript
grunt.initConfig({
});
</code></p>

<p>다음은 <code>pkg</code>프로퍼티에 <code>package.json</code>파일의 프로젝트 설정을 읽어서 설정한다. 이를 통해서 <code>package.json</code> 파일의 프로퍼티 값들을 참조할 수 있다. 조금만 더 읽으면 볼 수 있다.</p>

<p><code>javascript
pkg: grunt.file.readJSON("package.json");
</code></p>

<p>여기까지 본 것을 합치면 이렇게 된다.</p>

<p>```javascript
module.exports = function(grunt) {
  grunt.initConfig({</p>

<pre><code>pkg: grunt.file.readJSON('package.json')
</code></pre>

<p>  });
};
```</p>

<p>이제, task 별 환경설정을 정의할 수 있다. task를 위한 환경설정 객체는 전체 환경설정 객체에서 task 명과 동일한 이름의 프로퍼티로 존재한다. 즉, &ldquo;concat&rdquo; task는 환경설정 객체의 &ldquo;concat&rdquo; 프로퍼티에 있다. 다음은 &ldquo;concat"을 위한 task 환경설정 객체의 예제다.</p>

<p>```javascript
concat: {
  options: {</p>

<pre><code>// 합친 결과 파일에서 각 파일을 구분할 문자열을 정의한다. 
separator: ';'
</code></pre>

<p>  },
  dist: {</p>

<pre><code>// 합칠 파일들.
src: ['src/**/*.js'],
// 결과 js 파일의 위치
dest: 'dist/&lt;%= pkg.name %&gt;.js'
</code></pre>

<p>  }
}
```</p>

<p><code>package.json</code>의 <code>name</code> 프로퍼티를 어떻게 참조했는지 보이는가? 우리는 <code>package.json</code>을 불러온 결과가 들어있는 <code>pkg</code> 프로퍼티를 통해서 <code>pkg.name</code>로 접근했다. 이 값은 이미 자바스크립트 객체로 파싱되어있다. Grunt는 환경설정 객체의 프로퍼티 값을 뱉어내는 탬플릿 엔진을 가지고 있다. 여기서는 <code>src/</code> 폴더에서 확장자가 <code>.js</code>인 파일 전부를 합치는 concat task를 설정했다.</p>

<p>이번에는 자바스크립트를 minify(공백을 제거하고 변수명을 짧은 이름으로 바꾸는 작업)하는 uglify 플러그인을 설정해보자.</p>

<p>```javascript
uglify: {
  options: {</p>

<pre><code>// 결과 파일 상단에 주석을 넣는다. 
banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("dd-mm-yyyy") %&gt; */\n'
</code></pre>

<p>  },
  dist: {</p>

<pre><code>files: {
  'dist/&lt;%= pkg.name %&gt;.min.js': ['&lt;%= concat.dist.dest %&gt;']
}
</code></pre>

<p>  }
}
```</p>

<p>이제 uglify task는 minify한 자바스크립트 파일을 <code>dist/</code>에 생성한다. 여기서는 concat task에서 생성한 파일을 사용해서 minify를 진행하기 위해서 <code>&lt;%= concat.dis.dest %&gt;</code>를 사용했다.</p>

<p>QUnit 플러그인은 설정이 정말 간단한다. 그냥 QUnit을 실행하는 HTML 실행 파일(test runner)이 있는 위치만 지정하면 된다.</p>

<p><code>javascript
qunit: {
  files: ['test/**/*.html']
},
</code></p>

<p>JSHint 플러그인도 정말 간단한다.</p>

<p>```javascript
jshint: {
  // 검사를 실행할 파일을 지정한다.
  files: [&lsquo;gruntfile.js&rsquo;, &lsquo;src/<strong>/*.js&rsquo;, &lsquo;test/</strong>/*.js&rsquo;],
  // JSHint 환경설정 (<a href="http://www.jshint.com/docs/">http://www.jshint.com/docs/</a> 참고)
  options: {</p>

<pre><code>// 바꾸고 싶은 JSHint 기본값을 여기 지정한다. 
globals: {
  jQuery: true,
  console: true,
  module: true
}
</code></pre>

<p>  }
}
```</p>

<p>JSHint도 파일 목록이 담긴 배열과 옵션 객체만 설정하면 된다. JSHint에 대한 정보는 <a href="http://www.jshint.com/docs/">사이트</a>를 참고한다. JSHint를 기본값으로 잘 써왔다면, Gruntfile에서 재정의 할 필요없다.</p>

<p>끝으로 watch 플러그인을 보자.</p>

<p><code>javascript
watch: {
  files: ['&lt;%= jshint.files %&gt;'],
  tasks: ['jshint', 'qunit']
}
</code></p>

<p>이 task는 컴멘드 라인에 <code>grunt watch</code>를 입력해서 실행할 수 있다. 그러면, 설정한 파일에 어떤 변화가 감지될 때, 지정한 task들을 순서대로 실행한다. (여기서는 JSHint 확인을 위해서 같은 대상파일을 사용했다.)</p>

<p>이제, 필요한 Grunt 플러그인을 불러와야 하는데, 이들은 사전에 npm을 통해서 설치되어있어야 한다.</p>

<p><code>javascript
grunt.loadNpmTasks('grunt-contrib-uglify');
grunt.loadNpmTasks('grunt-contrib-jshint');
grunt.loadNpmTasks('grunt-contrib-qunit');
grunt.loadNpmTasks('grunt-contrib-watch');
grunt.loadNpmTasks('grunt-contrib-concat');
</code></p>

<p>그리고 나서 task를 몇 개 설정한다. 가장 중요한건 default task다.</p>

<p>```javascript
// 컴멘드 라인에 &ldquo;grunt test"를 입력하면 실행된다.
grunt.registerTask(&lsquo;test&rsquo;, [&lsquo;jshint&rsquo;, &lsquo;qunit&rsquo;]);</p>

<p>// default task는 컴멘드 라인에 &ldquo;grunt"만 입력했을 때 실행할 task들이다.
grunt.registerTask(&lsquo;default&rsquo;, [&lsquo;jshint&rsquo;, &lsquo;qunit&rsquo;, &lsquo;concat&rsquo;, &lsquo;uglify&rsquo;]);
```</p>

<p>전체 <code>Gruntfile.js</code>다.</p>

<p>```javascript
module.exports = function(grunt) {</p>

<p>  grunt.initConfig({</p>

<pre><code>pkg: grunt.file.readJSON('package.json'),
concat: {
  options: {
    separator: ';'
  },
  dist: {
    src: ['src/**/*.js'],
    dest: 'dist/&lt;%= pkg.name %&gt;.js'
  }
},
uglify: {
  options: {
    banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("dd-mm-yyyy") %&gt; */\n'
  },
  dist: {
    files: {
      'dist/&lt;%= pkg.name %&gt;.min.js': ['&lt;%= concat.dist.dest %&gt;']
    }
  }
},
qunit: {
  files: ['test/**/*.html']
},
jshint: {
  files: ['Gruntfile.js', 'src/**/*.js', 'test/**/*.js'],
  options: {
    // options here to override JSHint defaults
    globals: {
      jQuery: true,
      console: true,
      module: true,
      document: true
    }
  }
},
watch: {
  files: ['&lt;%= jshint.files %&gt;'],
  tasks: ['jshint', 'qunit']
}
</code></pre>

<p>  });</p>

<p>  grunt.loadNpmTasks(&lsquo;grunt-contrib-uglify&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-jshint&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-qunit&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-watch&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-concat&rsquo;);</p>

<p>  grunt.registerTask(&lsquo;test&rsquo;, [&lsquo;jshint&rsquo;, &lsquo;qunit&rsquo;]);</p>

<p>  grunt.registerTask(&lsquo;default&rsquo;, [&lsquo;jshint&rsquo;, &lsquo;qunit&rsquo;, &lsquo;concat&rsquo;, &lsquo;uglify&rsquo;]);</p>

<p>};
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt: Configuring tasks in korean]]></title>
    <link href="http://zziuni.github.io/blog/2013/11/17/grunt-configuring-tasks-in-korean/"/>
    <updated>2013-11-17T00:29:00+09:00</updated>
    <id>http://zziuni.github.io/blog/2013/11/17/grunt-configuring-tasks-in-korean</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://gruntjs.com">Grunt</a>은 Javascript Task Runner 입니다. 이 문서는 Grunt 공식 사이트의 <a href="http://gruntjs.com/configuring-tasks">Configuring Tasks</a>를 번역한 문서이며 grunt-cli의 버전이 0.1.10일 때 번역했습니다.</p></blockquote>

<h1>Configuring tasks</h1>

<p>이 문서는 <code>Gruntfile</code>를 사용하는 프로젝트를 위해서 task 단위로 환경설정을 하는 법을 설명한다. <code>Gruntfile</code>에 대해 잘 모른다면 <a href="http://gruntjs.com/getting-started">Getting Started</a> (<a href="http://zziuni.github.io/blog/2013/10/13/grunt-getting-started-in-korean/">번역문</a>)문서를 먼저 읽어보고 <a href="http://gruntjs.com/sample-gruntfile">Gruntfile 샘플</a> 파일을 체크아웃 받자.</p>

<h2>Grunt Configuration</h2>

<p>task 환경설정은 <code>Gruntfile</code>에서 <code>grunt.initConfig</code> 메서드를 통해서 지정한다. 일반적으로 환경설정은 task 명과 동일한 프로퍼티의 값으로 설정한다. 여러분이 설정한 task의 이름들과 충돌하지만 않으면 얼마든지 임의의 데이터를 넣을 수 있다. 물론 무시되지만.</p>

<!-- more -->


<p>또한, 이 파일은 JSON이 아닌 자바스크립트 파일이기 때문에, 모든 자바스크립트 코드를 사용할 수 있다. 필요하다면 동적으로 환경설정을 생성할 수도 있다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    // concat task를 위한 환경설정은 여기에 넣는다.
  },
  uglify: {
    // uglify task를 위한 환경설정은 여기에 넣는다. 
  },
  // 특정 task와 관련없는 임의의 프로퍼티
  my_property: 'whatever',
  my_src_files: ['foo/*.js', 'bar/*.js'],
});
</code></pre>

<p>```</p>

<h2>Task Configuration and Targets</h2>

<p>task 하나가 실행되면, Grunt는 그 task의 이름으로 <code>Gruntfile</code>의 환경설정 객체에서 프로퍼티를 찾고 이를 해당 task의 환경설정으로 사용한다. 여러 일을 한 번에 하는 multi-task는 다시 별도의 target 명을 사용해서 환경설정을 개별적으로 가질 수 있다. 다음 예제를 보면 <code>uglify</code> task는 <code>bar</code> target만 가지고 있지만, <code>concat</code> task는 <code>foo</code>와 <code>bar</code>라는 두 개의 target을 갖고 있다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    foo: {
      // concat task의 "foo" 타겟을 위한 옵션과 파일을 여기에 넣는다. 
    },
    bar: {
      // concat task의 "bar" 타겟을 위한 옵션과 파일을 여기에 넣는다. 
    },
  },
  uglify: {
    bar: {
      // uglify task의 "bar" 타겟을 위한 옵션과 파일을 여기에 넣는다. 
    },
  },
});
</code></pre>

<p>```</p>

<p><code>grunt concat</code>를 입력하면 모든 target을 순회하며, 차례대로 모든 target의 환경설정을 가져오는 반면에, <code>grunt concat:foo</code>나 <code>grunt concat:bar</code>처럼 task와 target을 모두 사용해서 지정하면 특정 target의 환경설정만 가져온다. 단, task 명이 <strong>grunt.renameTask</strong>로 변경되면, Grunt는 새로운 task 명으로 config 객체에서 프로퍼티 명을 찾는다.</p>

<h2>Options</h2>

<p>task 환경설정 하나를 살펴보자, <code>options</code> 프로퍼티는 내장된 기본값을 재정의 하기 위해서 덮어 쓸 때 사용한다. 그리고 각 target 별로도 해당 target에만 한정된 <code>options</code> 프로퍼티를 가질 수 있다. target 레벨의 options는 해당 타겟 레벨에서만 덮어써진다.</p>

<p><code>options</code> 프로퍼티는 필수요소가 아니며, 필요없는 경우 무시된다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    options: {
      // task 수준의 옵션 객체. task 기본값을 덥어쓴다. 
    },
    foo: {
      options: {
        // "foo" target 수준의 옵션 객체. task 수준의 options을 덥어쓴다. 
      },
    },
    bar: {
      // 명시된 options가 없다. 이 target은 task 수준의 options을 사용한다.
    },
  },
});
</code></pre>

<p>```</p>

<h2>Files</h2>

<p>대부분의 task는 파일을 대상으로하는 작업들이므로, Grunt는 task가 작업 대상 파일을 선언하기 위한 추상화된 기능을 강력하게 지원한다. <strong>src-dest</strong>(출처와 목적지)간의 파일 매핑을 정의하는 방법은 여러 가지가 있다. 매핑의 표현과 제어도 지속적으로 변경 가능하면서 말이다.
이제부터 설명할 유형들은 모든 task에서 사용할 수 있으므로, 여러분 상황에 맞는 포맷을 선택하면 된다.</p>

<p><code>src</code>와 <code>dest</code>는 모두 파일 포맷에서 지원하지만 &ldquo;Compact"와 "Files Array&rdquo; 포맷에서는 몇 가지 추가 프로퍼티를 사용할 수 있다.</p>

<ul>
<li><code>fileter</code>: 필터용도로 유효한 <a href="http://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats">fs.Stats 메서드명</a>이나 함수를 적용한다. 이때, 함수는 적절한 <code>src</code> 파일경로를 받으면 <code>true</code>나 <code>false</code>를 반환해야 한다.</li>
<li><code>nonull</code>: <code>true</code>를 지정했을 때는 패턴과 일치하는 내용이 없는 경우, 그 패턴 자체를 담은 목록을 반환하고, <code>false</code>를 지정했을 때는 패턴과 일치하는 내용이 없는 경우, 빈 목록을 반환한다. <code>--verbos</code>와 함께 사용하면 파일 경로 관련 버그를 찾을 때 유용하다.</li>
<li><code>dot</code>: <code>true</code>면 패턴에 명시적으로 포함시키지 않아도 구두점(.)으로 시작하는 파일명을 일치시킨다.(src/*.js 하면 hidden files도 포함된다는 말.)</li>
<li><code>matchBase</code>: <code>true</code>면, 슬래시(/)를 포함하지 않은 패턴들이 슬래시를 가지고 있을 경로 기본명을 제외하고 매치된다. 예를 들어 <code>a?b</code> 패턴이 <code>/xyz/acb/123</code>이 아니라 <code>/xyz/123/acb</code>와 일치한다.</li>
<li><code>expand</code>은 동적인 src-dest 파일 매핑을 수행한다. 더 자세한 정보는 <a href="http://gruntjs.com/configuring-tasks#building-the-files-object-dynamically">Building the files object dynamically</a>를 참고한다.</li>
<li>이 이외의 프로퍼티들은 매칭 옵션으로 하위 libs로 전달된다. 추가 옵션은 <a href="https://github.com/isaacs/node-glob">node-glob</a>와 <a href="https://github.com/isaacs/minimatch">minimatch</a>를 보자.</li>
</ul>


<h3>Compact Format</h3>

<p>이 형태는 target 별로 단일 <strong>src-dest</strong> 파일 매핑을 할 때 사용한다. 주로 <a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint</a>처럼 <code>dest</code>와 관계없이 <code>src</code> 프로퍼티 하나만 필요한 읽기 전용 task를 위해서 사용한다. src-dest 파일 매핑 별로 프로퍼티 확장도 가능하다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  jshint: {
    foo: {
      src: ['src/aa.js', 'src/aaa.js']
    },
  },
  concat: {
    bar: {
      src: ['src/bb.js', 'src/bbb.js'],
      dest: 'dest/b.js',
    },
  },
});
</code></pre>

<p>```</p>

<h3>Files Object Format</h3>

<p>이 형태는 target 별로 다중 src-dest 매핑을 할 때 사용한다. 프로퍼티 명이 목적지(destination) 파일명이고 프로퍼티 값은 출처(source) 파일이 된다. 이 방법을 사용하면 src-dest 파일 매핑이 아무리 많아도 지정할 수 있다. 하지만 매핑 별로 추가 파라미터 지정은 불가능하다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    foo: {
      files: {
        'dest/a.js': ['src/aa.js', 'src/aaa.js'],
        'dest/a1.js': ['src/aa1.js', 'src/aaa1.js'],
      },
    },
    bar: {
      files: {
        'dest/b.js': ['src/bb.js', 'src/bbb.js'],
        'dest/b1.js': ['src/bb1.js', 'src/bbb1.js'],
      },
    },
  },
});
</code></pre>

<p>```</p>

<h3>Files Array Format</h3>

<p>이 형태는 target 별로 다중 src-dest 매핑을 지원하면서 매핑 별로 추가 프로퍼티를 사용할 수 있다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    foo: {
      files: [
        {src: ['src/aa.js', 'src/aaa.js'], dest: 'dest/a.js'},
        {src: ['src/aa1.js', 'src/aaa1.js'], dest: 'dest/a1.js'},
      ],
    },
    bar: {
      files: [
        {src: ['src/bb.js', 'src/bbb.js'], dest: 'dest/b/', nonull: true},
        {src: ['src/bb1.js', 'src/bbb1.js'], dest: 'dest/b1/', filter: 'isFile'},
      ],
    },
  },
});
</code></pre>

<p>```</p>

<h3>Older Formats</h3>

<p><strong>dest as targets</strong> 파일 형태는 멀티 task와 target가 있기 전부터 있던 형태로 목적지(destination) 파일 경로가 그대로 target 명이 된다. 하지만 이 때문에 <code>grunt task:target</code>의 형태로 동작시키기가 거북할 수 있다. 또한 src-dest 매핑 별로 target 수준의 옵션이나 추가 프로퍼티를 지정할 수 없다.</p>

<p>이 형태는 되도록 사용하지 말고 가능하면 피하자.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    'dest/a.js': ['src/aa.js', 'src/aaa.js'],
    'dest/b.js': ['src/bb.js', 'src/bbb.js'],
  },
});
</code></pre>

<p>```</p>

<h3>Custom Filter Function</h3>

<p><code>filter</code> 프로퍼티를 사용하면 파일을 좀 더 꼼꼼하게 지정할 수 있다. 그냥 적절한 <a href="http://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats">fs.Stats 메서드명</a>을 사용하자. 다음 예제는 패턴과 일치하는 파일만 제거(clean)한다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  clean: {
    foo: {
      src: ['tmp/**/*'],
      filter: 'isFile',
    },
  },
});
</code></pre>

<p>```</p>

<p>아니면 파일 일치 여부에 따라 <code>true</code>, <code>false</code>를 반환하는 <code>filter</code>용 함수를 생성하자. 다음 예제는 빈 폴더만 지우는 필터다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  clean: {
    foo: {
      src: ['tmp/**/*'],
      filter: function(filepath) {
        return (grunt.file.isDir(filepath) &amp;&amp; require('fs').readdirSync(filepath).length === 0);
      },
    },
  },
});
</code></pre>

<p>```</p>

<h3>Globbing patterns</h3>

<p>대상(source) 파일 경로를 모두 개별적으로 지정하는 일이 불가능할 때도 있다. 그래서 Grunt는 <a href="https://github.com/isaacs/node-glob">node-glob</a>와 <a href="https://github.com/isaacs/minimatch">minimatch</a>라이브러리를 내부에 포함시켰고, 이를 통해서 파일명 확장을 지원한다. (globbing이라고도 한다.)</p>

<p>이 문서는 globbing 패턴 전반을 다루는 튜토리얼이 아니므로, 파일경로에서 사용할 수 있는 몇 가지만 소개한다.</p>

<ul>
<li><code>*</code>는 개수와 관계없이 <code>/</code>를 제외한 모든 캐릭터와 일치한다.</li>
<li><code>?</code>는 <code>/</code>를 제외한 하나의 캐릭터와 일치한다.</li>
<li><code>**</code>는 개수와 관계없이 <code>/</code>를 포함한 모든 캐릭터와 일치한다. 하지만 경로부분(폴더명)에서만 동작한다.</li>
<li><code>{}</code>에 콤마로 구분된 목록을 넣으면 &ldquo;or&rdquo; 표현식으로 동작한다.</li>
<li><code>!</code>를 패턴의 처음에 사용하면 불일치(negative match)를 의미한다.</li>
</ul>


<p>globbing 패턴을 잘 모르더라도 <code>foo/*.js</code>는 <code>foo/</code> 폴더에서 <code>.js</code>로 끝나는 모든 파일과 일치하지만, <code>foo/**/*.js</code>는 <code>foo/</code> 폴더와 그 아래의 모든 하위 폴더에서 <code>.js</code>로 끝나는 모든 파일과 일치한다는 것 정도는 알아두면 좋다.</p>

<p>globbing 패턴의 복잡함을 줄이기 위해서, Grunt에서는 파일 경로나 globbing 패턴을 배열로 지정할 수 있다. 패턴은 모두 배열의 색인 순서대로 처리되는데, 결과 집합에서 일치하는 파일을 제외하는 <code>!</code> 접두사 패턴도 마찬가지다. 최종 결과 집합은 중복값이 없는 유일값들이다.</p>

<p>예제을 보자.</p>

<p>```javascript</p>

<pre><code>// 단일 파일 지정. 
{src: 'foo/this.js', dest: ...}
// 배열로 여러 파일 지정.
{src: ['foo/this.js', 'foo/that.js', 'foo/the-other.js'], dest: ...}
// glob 패턴 사용.
{src: 'foo/th*.js', dest: ...}

// 단일 node-glob 패턴.
{src: 'foo/{a,b}*.js', dest: ...}
// 물론 이렇게도 사용 가능.
{src: ['foo/a*.js', 'foo/b*.js'], dest: ...}

// foo/ 안의 모든 .js 파일. 순서는 알파벳 순.
{src: ['foo/*.js'], dest: ...}
// bar.js을 먼저 선택하고, 남은 파일을 알파벳 순으로 추가.
{src: ['foo/bar.js', 'foo/*.js'], dest: ...}

// bar.js를 제외한 모든 파일. 알파벳 순.
{src: ['foo/*.js', '!foo/bar.js'], dest: ...}
// 모든 파일을 알파벳 순서로 넣고, 끝에 bar.js를 추가.
{src: ['foo/*.js', '!foo/bar.js', 'foo/bar.js'], dest: ...}

// 파일경로나 glob 패턴에 템플릿(&lt;%%&gt;)을 사용할 수도 있다.
{src: ['src/&lt;%= basename %&gt;.js'], dest: 'build/&lt;%= basename %&gt;.min.js'}
// 환경설정의 다른 task의 target에서 정의한 파일 목록을 참조할 수도 있다.
{src: ['foo/*.js', '&lt;%= jshint.all.src %&gt;'], dest: ...}
</code></pre>

<p>```</p>

<p>더 자세한 glob 패턴 문법은 <a href="https://github.com/isaacs/node-glob">node-glob</a>와 <a href="https://github.com/isaacs/minimatch">minimatch</a> 문서를 참고하자.</p>

<h3>Building the fiels object dynamically</h3>

<p>대량의 파일들을 처리하고자 할 때, 파일 목록을 동적으로 생성하는데 사용가능한 몇 가지 추가 프로퍼티들이 있다. 이 프로퍼티들은 &ldquo;Compact"와 "Files Array&rdquo; 매핑 패턴에 지정할 수 있다.</p>

<ul>
<li><code>expand</code>: 다음 옵션들을 활성화하려면 먼저 이 프로퍼티를 <code>true</code>로 설정한다.</li>
<li><code>cwd</code>: 모든 <code>src</code> 패턴을 이 옵션에 정의된 경로를 기준으로 정한다.</li>
<li><code>src</code>: 일치 여부 확인을 위한 패턴 목록. <code>cwd</code>기준 상대경로.</li>
<li><code>dest</code>: 목적지 지정을 위한 경로 접두사.</li>
<li><code>ext</code>: <code>dest</code> 경로에 생성할 파일의 확장자.</li>
<li><code>flatten</code>: <code>dest</code> 경로에 생성할 목록에서 경로부분을 제거하고 파일명만 남긴다.</li>
<li><code>rename</code>: 일치하는 <code>src</code> 파일별로 호출되는 함수. 이 함수는 (확장자 변경과 경로 제거 후) 일치하는 <code>src</code> 패턴과 <code>dest</code>를 인자로 받아서, 새로운 <code>dest</code> 값을 반환해야 한다. 동일 <code>dest</code> 값이 여러 번 반환되면, 사용된 <code>src</code>들이 이름변경을 위한 출처 배열에 추가된다.</li>
</ul>


<p>다음 <code>minify</code> task 예제는 <code>static_mappings</code>와 <code>dynamic_mappings</code> target에서 동일한 src-dest 파일 매핑을 바라보고 있다. task를 실행하면, Grunt는 자동으로 <code>dynamic_mappings</code> 파일 목록을 정적인 4개의 src-dest 파일 매핑으로 바꾼다.</p>

<p>또한, 정적인 매핑과 동적인 매핑은 다양한 방법으로 함께 쓸 수 있다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  minify: {
    static_mappings: {
      // 이 src-dest 파일 매핑은 수동으로 지정했기 때문에, 
      // 파일 추가 삭제와 Grunfile 수정을 매번 해줘야 한다.
      files: [
        {src: 'lib/a.js', dest: 'build/a.min.js'},
        {src: 'lib/b.js', dest: 'build/b.min.js'},
        {src: 'lib/subdir/c.js', dest: 'build/subdir/c.min.js'},
        {src: 'lib/subdir/d.js', dest: 'build/subdir/d.min.js'},
      ],
    },
    dynamic_mappings: {
      // "minify" task가 실행되면 Grunt는 "lib/" 아래에서 "**/*.js"를 찾는다. 
      // 그렇게 찾은 src-dest 파일 매핑으로 빌드한다. 
      // 파일이 추가/제거 될 때 마다 Gruntfile을 수정할 필요없다.
      files: [
        {
          expand: true,     // 동적 기술법을 활성화.
          cwd: 'lib/',      // Src 패턴의 기준 폴더.
          src: ['**/*.js'], // 비교에 사용할 패턴 목록.
          dest: 'build/',   // 목적 경로의 접두사(사실상 폴더명)
          ext: '.min.js',   // dest의 파일들의 확장자.
        },
      ],
    },
  },
});
</code></pre>

<p>```</p>

<h2>Templates</h2>

<p><code>&lt;%%&gt;</code> 구분자를 사용한 템플릿은 task가 해당 환경설정을 읽어올 때 자동으로 정적인 값으로 기술된다. 그리고 이는 템플릿를 모두 기술될 때 까지 재귀적으로 실행된다.</p>

<p><code>grunt.initConfig()</code>의 환경설정 객체는 프로퍼티 설정시 컨텍스트로 사용되며, <code>grunt</code>와 그 메서드도 그 안에서 사용할 수 있다. 예) <code>&lt;%= grunt.template.today('yyyy-mm-dd') %&gt;</code></p>

<ul>
<li><code>&lt;%= prop.subprop%&gt;</code>는 환경설정 객체에서 <code>prop.subprop</code>을 찾아서 그 값으로 치환된다. 타입은 관계없다. 이같은 템플릿은 문자열 만이 아니라 배열과 다른 객체로 참조할 수도 있다.</li>
<li><code>&lt;% %&gt;</code>는 임의의 인라인 자바스크립트 코드를 실행한다. 그래서 흐름제어나 순회를 위해 사용할 수 있다.</li>
</ul>


<p>여기 <code>concat</code> task가 있다. <code>grunt concat:sample</code>을 실행하면 <code>foo/*.js</code> + <code>bar/*.js</code> + <code>baz/*.js</code>와 일치하는 파일을 합치고 <code>/* abcde */</code> 상단 주석(banner)를 추가해서 <code>build/abcde.js</code>란 이름으로 생성한다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    sample: {
      options: {
        banner: '/* &lt;%= baz %&gt; */\n',   // '/* abcde */\n'
      },
      src: ['&lt;%= qux %&gt;', 'baz/*.js'],  // [['foo/*.js', 'bar/*.js'], 'baz/*.js']
      dest: 'build/&lt;%= baz %&gt;.js',      // 'build/abcde.js'
    },
  },
  // task 환경설정 템플릿에 사용되는 임의의 프로퍼티들
  foo: 'c',
  bar: 'b&lt;%= foo %&gt;d', // 'bcd'
  baz: 'a&lt;%= bar %&gt;e', // 'abcde'
  qux: ['foo/*.js', 'bar/*.js'],
});
</code></pre>

<p>```</p>

<h2>Importing External Data</h2>

<p>다음 <code>Gruntfile</code> 파일은 <code>package.json</code> 파일에서 프로젝트 관련 메타데이터를 가져온다. 그리고 그 메타데이터를 <a href="http://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify 플러그인</a>의 <code>uglify</code> task의 상단 주석 생성과 src 파일 minify를 위한 정보로 사용한다.</p>

<p>Grunt는 JSON과 YAML 데이터를 가져올 수 있는 <code>grunt.file.readJSON</code>와 <code>grunt.file.readYAML</code>를 지원한다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  pkg: grunt.file.readJSON('package.json'),
  uglify: {
    options: {
      banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'
    },
    dist: {
      src: 'src/&lt;%= pkg.name %&gt;.js',
      dest: 'dist/&lt;%= pkg.name %&gt;.min.js'
    }
  }
});
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt: Getting started in korean]]></title>
    <link href="http://zziuni.github.io/blog/2013/10/13/grunt-getting-started-in-korean/"/>
    <updated>2013-10-13T00:01:00+09:00</updated>
    <id>http://zziuni.github.io/blog/2013/10/13/grunt-getting-started-in-korean</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://gruntjs.com">Grunt</a>은 Javascript Task Runner 입니다. 이 문서는 Grunt 공식 사이트의 <a href="http://gruntjs.com/getting-started">Getting Started</a>를 번역한 문서이며 grunt-cli의 버전이 0.1.7일 때 번역했습니다.</p></blockquote>

<h1>Getting started</h1>

<p><img src="http://gruntjs.com/img/grunt-logo.svg" alt="" /></p>

<p>Grunt와 Grunt 플러그인의 설치와 관리는 <a href="https://npmjs.org">npm</a>을 통해서 한다. npm은 <a href="http://nodejs.org">Node.js</a>의 패키지 메니징 도구다.</p>

<p>Grunt 0.4.x를 사용하려면 Node.js 버전이 <code>&gt;=0.8.0</code> 이여야 한다.</p>

<h2>Installing the CLI</h2>

<p><strong>Grunt 0.3을 이미 사용하고 있고 0.4.x로 업그레이드 하는 거라면, <a href="http://gruntjs.com/getting-started#grunt-0.3-notes">Grunt 0.3 Notes</a> 문서를 먼저 보자.</strong></p>

<p>Grunt를 사용하려면 먼저 Grunt&rsquo;s Command line interface (CLI)를 설치해야 한다. 이때 OSX나 nix, BSD에서는 sudo가, 윈도우즈에서는 administrator 권한이 필요할 수도 있다.</p>

<pre><code>npm install -g grunt-cli
</code></pre>

<p><code>grunt-cli</code>를 설치하면 여러분의 시스템 경로에 자동으로 <code>grunt</code>를 추가해서, 어느 디렉토리에서나 <code>grunt</code>를 사용할 수 있게 만든다.</p>

<!-- more -->


<p>하지만 <code>grunt-cli</code>는 Grunt task runner(즉, <code>grunt</code>)를 설치하지는 않는다. Grunt CLI의 역할은 간단하다. <code>Gruntflie</code>라는 파일이 있는 위치에 설치된 Grunt를 실행하는 것이다. 즉, 같은 장비에서 여러 버전의 Grunt를 설치할 수 있다.</p>

<h2>How the CLI works</h2>

<p><code>grunt</code>를 실행하면 grunt-cli는 node의 <code>require()</code>를 사용해서 프로젝트 로컬의 grunt를 실행한다. 그러므로 프로젝트 루트 폴더가 아니여도 하위 폴더 어디서든 <code>grunt</code>를 실행할 수 있다.</p>

<p>특정 위치에 설치된 Grunt를 찾으면, CLI는 Grunt 라이브러리의 로컬 인스톨본을 불러온다. 이때 <code>Gruntfile</code>라는 파일로 환경설정을 적용하고, 특정 동작을 위해 설정한 task들을 실행한다.</p>

<p>이때 일어라는 일이 궁금하면 <a href="https://github.com/gruntjs/grunt-cli/blob/master/bin/grunt">코드</a>를 읽어보자. 겁나 짧다.</p>

<h2>Preparing a new grunt project</h2>

<p>일반적인 설치과정에서는 프로젝트에 <code>package.json</code>과 <code>Grunfile</code>라는 파일이 있어야 한다.</p>

<p><strong>package.json</strong>: 이 파일은 <a href="https://npmjs.org/">npm</a>이 해당 프로젝트를 npm 모듈로 퍼블리싱할 때 사용하는 메타데이터 저장 파일이다. 이 파일의 <a href="https://npmjs.org/doc/json.html#devDependencies">devDependencies</a> 항목에 프로젝트에 필요한 grunt와 Grunt 플러그인들을 나열할 수 있다.</p>

<p><strong>Gruntfile</strong>: 이 파일의 이름은 <code>Gruntfile.js</code>이거나 <code>Gruntfile.coffee</code>이다. task를 설정하거나 정의하고 Grunt 플러그인을 불러오는데 사용한다.</p>

<h3>package.json</h3>

<p><code>package.json</code>파일은 <code>Gruntfile</code>과 함께 프로젝트 루트 디렉토리에 있어야 하고, 프로젝트 소스와 함께 커밋(commit)되야 한다. <code>package.json</code>이 있는 폴더에서 컴맨드 명령어 <code>npm install</code>를 실행하면 이 파일 안에 있는 dependency 목록의 모듈들을 해당 버전으로 인스톨한다.</p>

<p>프로젝트에 <code>package.json</code>를 추가하는 방법은 여러가지가 있다.</p>

<ul>
<li>대부분의 <a href="http://gruntjs.com/project-scaffolding#h5o-9">grunt-init</a> 템플릿은 자동으로 프로젝트 전용  <code>package.json</code>파일을 생성한다.</li>
<li><a href="https://npmjs.org/doc/init.html">npm init</a> 컴맨드 명령어는 기본 <code>package.json</code>을 생성한다.</li>
<li>다음 예제를 기초로 필요한 부분은 <a href="https://npmjs.org/doc/json.html">specification</a> 문서를 참고 해서 확장한다.</li>
</ul>


<p>```javascript</p>

<pre><code>{
  "name": "my-project-name",
  "version": "0.1.0",
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-contrib-jshint": "~0.6.3",
    "grunt-contrib-nodeunit": "~0.2.0",
    "grunt-contrib-uglify": "~0.2.2"
  }
}
</code></pre>

<p>```</p>

<h4>Installing Grunt and gruntplugins</h4>

<p>Grunt와 플러그인을 설치와 동시에 <code>package.json</code>와 연동시키려면 <code>npm install &lt;module&gt; --save-dev</code> 컴맨드 명령어를 사용한다. 이러면 <code>&lt;module&gt;</code>만 설치하고 끝나지 않고, 자동으로 <code>package.json</code>의 <a href="https://npmjs.org/doc/json.html#devDependencies">devDependencies</a> 항목에 추가된다. 버전은 <a href="https://npmjs.org/doc/json.html#version">tiled version range</a>를 사용한다.</p>

<p>예를 들면, 다음 컴맨드 명령어는 프로젝트에 Grunt 최신버전을 설치하고 <code>package.json</code>의 devDependencies 항목에 grunt를 추가한다.</p>

<pre><code>npm install grunt --save-dev
</code></pre>

<p>grunt 플러그인과 다른 node 모듈도 마찬가지다. 이렇게 설치하면 프로젝트의 <code>package.json</code>이 갱신된다.</p>

<h3>The Gruntfile</h3>

<p><code>Gruntfile.js</code>나 <code>Gruntfile.coffee</code>파일은 프로젝트 루트 폴더에 있어야 하는 자바스크립트 혹은, 커피스크립트 파일이다. 그리고 이 파일은 프로젝트 소스의 일부로 같이 커밋되야 한다.</p>

<p>다음은 <code>Gruntfile</code>의 내부 구성요소다.</p>

<ul>
<li>&ldquo;wrapper&rdquo; 함수.</li>
<li>프로젝트와 task의 환경설정.</li>
<li>grunt plugin과 task 로딩.</li>
<li>사용자 정의 task</li>
</ul>


<h4>An sample Gruntfile</h4>

<p>다음 <code>Gruntfile</code>은 프로젝트의 메타데이터를 <code>package.json</code>에서 가져와서 Grunt config로 주입한다. 그리고 <a href="http://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a> 플러그인의 <code>uglify</code> task을 사용해서 소스코드를 미니파이(minify)하도록 설정하고, 메타데이터를 이용해서 동적인 베너 주석도 생성한다. 그리고 <code>uglify</code> task를 컴맨드 라인에서 <code>grunt</code> 명령어를 실행할 때 실행되는 기본 task로 지정했다.</p>

<p>```javascript</p>

<pre><code>module.exports = function(grunt) {

  // Project configuration.
  grunt.initConfig({
    pkg: grunt.file.readJSON('package.json'),
    uglify: {
      options: {
        banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'
      },
      build: {
        src: 'src/&lt;%= pkg.name %&gt;.js',
        dest: 'build/&lt;%= pkg.name %&gt;.min.js'
      }
    }
  });

  // Load the plugin that provides the "uglify" task.
  grunt.loadNpmTasks('grunt-contrib-uglify');

  // Default task(s).
  grunt.registerTask('default', ['uglify']);

};
</code></pre>

<p>```</p>

<p>이 코드가 <code>Grunfile</code> 전체 코드다. 파트별로 살펴보자.</p>

<h4>The &ldquo;wrapper&rdquo; function</h4>

<p>모든 <code>Gruntfile</code>(그리고 그 플러그인)은 래퍼(wrapper) 함수를 기본 형태로 사용한다. 모든 Grunt 코드는 이 함수 안쪽에 있어야 한다.</p>

<p>```javascript</p>

<pre><code>module.exports = function(grunt){
    // Do grunt-related things in here
}
</code></pre>

<p>```</p>

<h4>Project and task configuration</h4>

<p>대부분의 Grunt task는 configuration을 위한 데이터로 <a href="http://gruntjs.com/grunt#grunt.initconfig">grunt.initConfig</a> 메서드의 인자로 전달되는 객체를 사용한다.(이를 configuraton 객체라 하자.)</p>

<p>위의 예제에서, <code>grunt.file.readJSON('package.json')</code> 코드는 grunt config로 <code>package.json</code>에 저장된 JOSN 메타데이터를 인포트한다. 그러면 <code>&lt;% %&gt;</code> 템플릿 문자열을 사용해서 config의 모든 프로퍼티를 참조할 수 있다.(<code>package.json</code>값을 불러올 수 있다는 말이다.) 파일패스나 파일 목록 같은 configuration 데이터는 반복을 줄이기 위해서 이 방법으로 지정한다.</p>

<p>여러분의 task가 필요로하는 프로퍼티와 충돌하지 않는 이상 configuraton 객체안에는 어떤 값을 넣어도 상관없다. 그리고 이 파일은 단순 JSON이 아닌 자바스크립트 파일이므로, 유효한 JS코드는 모두 사용가능하다. 즉, 필요한 configuration을 동적으로 생성할 수도 있다.</p>

<p>다른 task도 마찬가지지만, <a href="http://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a> 플러그인의 <code>uglify</code> task는 configuration 객체에서 동명의 프로퍼티 명(uglify)으로 설정에 필요한 값을 찾는다. 여기서는 옵션값인 <code>banner</code>와 소스파일(src) 하나를 타겟파일(dest) 하나로 미니파이(minify)하는 어그리파이(uglify) 타겟명인 <code>build</code>를 지정했다.</p>

<p>```javascript</p>

<pre><code>// Project configuration.
grunt.initConfig({
  pkg: grunt.file.readJSON('package.json'),
  uglify: {
    options: {
      banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'
    },
    build: {
      src: 'src/&lt;%= pkg.name %&gt;.js',
      dest: 'build/&lt;%= pkg.name %&gt;.min.js'
    }
  }
});
</code></pre>

<p>```</p>

<h4>Loading grunt plugins and tasks</h4>

<p>자주 사용하는 <a href="https://github.com/gruntjs/grunt-contrib-concat">concatenation</a>, <a href="http://github.com/gruntjs/grunt-contrib-uglify">minification</a>, <a href="https://github.com/gruntjs/grunt-contrib-jshint">linting</a>같은 task들은 <a href="https://github.com/gruntjs">grunt plugin</a>으로 설정해서 사용할 수 있다. 즉, <code>package.json</code>의 dependency에 플러그인을 설정했다면, <code>npm install</code>을 통해서 이미 설치된 것이므로, 간단한 코드 추가로 <code>Gurntfile</code>에서 사용 가능하다.</p>

<p>```javascript</p>

<pre><code>// Load the plugin that provides the "uglify" task.
grunt.loadNpmTasks('grunt-contrib-uglify');
</code></pre>

<p>```</p>

<p><strong>참고</strong>: <code>grunt --help</code> 명령어를 사용하면 사용가능한 taks 목록을 볼 수 있다.</p>

<h4>Custom tasks</h4>

<p><code>default</code> task를 설정하면 기본으로 실행할 task를 하나 혹은 그 이상 지정할 수 있다. 예를 들면, 컴맨드 라인에 특정 task를 지정하지 않고 <code>grunt</code>만 입력하면 <code>uglify</code> task가 실행된다. 이는 실제로는 <code>grunt uglify</code>나 <code>grunt default</code>와 같다. 배열 안에는 다수의 task를 지정할 수도 있다. (아규먼트는 있을 수도 있고 없을 수도 있다.)</p>

<p>```javascript</p>

<pre><code>// Default task(s)
grunt.registerTask('default', ['uglify']);
</code></pre>

<p>```</p>

<p>만약 프로젝트에서 Grunt 플러그인 목록에 없는 task가 필요하다면, <code>Gruntfile</code>에 직접 custom task를 만들 수도 있다. 예를 들면, 다음 <code>Gruntfile</code>은 task configuration을 전혀 활용하지 않는 custom <code>default</code> task를 정의한다.</p>

<p>```javascript</p>

<pre><code>module.exports = function(grunt){

      // A very basic default task.
      grunt.registorTask('default', 'Long some stuff', function() {
          grunt.log.write('Logging some stuff...').ok();
      });
};
</code></pre>

<p>```</p>

<p>프로젝트 전용 task라면 <code>Gruntfile</code>안에 정의할 필요없이. 별도의 <code>.js</code> 파일로 정의하고 <a href="http://gruntjs.com/grunt#grunt.loadtasks">grunt.loadTask</a> 메서드로 불러와도 된다.</p>

<h3>Further Reading</h3>

<ul>
<li><a href="http://gruntjs.com/installing-grunt/">Installing grunt</a> 가이드는 인스톨 스펙, 프로덕션, 개발, Grunt와 grunt-cli의 버전에 대한 상세한 정보를 제공한다.</li>
<li><a href="http://gruntjs.com/configuring-tasks/">Configuring Tasks</a> 가이드는 <code>Gruntfile</code>에서 task, target, option, file을 설정하는 방법을 상세하게 설명한다. tempaltes, globbing pattern, importing external data도 설명한다.</li>
<li><a href="http://gruntjs.com/creating-tasks/">Creating Tasks</a> 가이드에는 Grunt task의 타입간의 차이점 목록이 있으며, task와 configuration의 샘플도 제공한다.</li>
<li>custom task나 Grunt 플러그인에 대한 더 많은 정보는 <a href="http://gruntjs.com/grunt">developer documentation</a>을 확인하자.</li>
</ul>


<h3>Grunt 0.3 Notes</h3>

<p>Grunt 0.3에서 업그레이드 할거라면 전역 <code>grunt</code>를 제거해야 한다.</p>

<p>```javascript</p>

<pre><code>npm install -g grunt
</code></pre>

<p>```</p>

<p><em>이 안내서는 Grunt 0.4.x를 위해 작성되었다. 그렇다고 Grunt 0.3.x에서 참고할 수 없는건 아니다. 다만, &ldquo;The Gruntfile"절의 플러그인 명과 task configuration 옵션은 다를 수 있다.</em></p>
]]></content>
  </entry>
  
</feed>
