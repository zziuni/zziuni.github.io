<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | zziuni's Blog]]></title>
  <link href="http://zziuni.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://zziuni.github.io/"/>
  <updated>2013-12-01T18:21:37+09:00</updated>
  <id>http://zziuni.github.io/</id>
  <author>
    <name><![CDATA[zziuni]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Grunt: Create tasks in korean]]></title>
    <link href="http://zziuni.github.io/blog/2013/12/01/grunt-create-tasks-in-korean/"/>
    <updated>2013-12-01T12:11:00+09:00</updated>
    <id>http://zziuni.github.io/blog/2013/12/01/grunt-create-tasks-in-korean</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://gruntjs.com">Grunt</a>은 Javascript Task Runner 입니다.. 이 문서는 Grunt 공식 사이트의 <a href="http://gruntjs.com/creating-tasks">Create tasks</a>를 번역한 문서이며 grunt-cli의 버전이 0.1.11일 때 번역했습니다.</p></blockquote>

<h1>Create tasks</h1>

<p>Task는 Grunt의 존재 이유이자 가장 중요한 개념이다. 여러분이 하는 대부분의 일(task)은 <code>jshint</code>나 <code>nodeunit</code>같은 것들이다. 실행할 Task를 하나 이상 명시해서 Grunt에게 하고 싶은 일이 무엇인지 알려주면, Grunt가 그 일을 매번 실행한다.</p>

<p>여러분이 task를 새로 명시하지 않았고, &ldquo;default"란 이름의 task가 이미 정의되어 있다면, 기본값으로 그 task가 실행된다.</p>

<!-- more -->


<h2>Alias Tasks</h2>

<p>다음처럼 새로운 task에 다른 task 명단을 명시하면, 그 신규 task의 이름은 여러 task들을 대표하는 별명(alias)이 된다. 이런 &ldquo;alias task"가 실행될 때면, <code>taskList</code>에 명시한 모든 task들이 순서대로 실행된다. 이때 <code>taskList</code> 전달인자는 배열이다.</p>

<p><code>javascript
grunt.registerTask(taskName, [description, ] taskList)
</code></p>

<p>다음 예제는 Grunt를 특정 task 지정없이 <code>grunt</code>로 실행할 때 자동으로 &ldquo;jshint&rdquo;, &ldquo;qunit&rdquo;, &ldquo;concat&rdquo;, &ldquo;uglify&rdquo; task들을 실행하는 &ldquo;default"라는 alias task다.</p>

<p><code>javascript
grunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']);
</code></p>

<p>Task 전달인자를 다음처럼 지정할 수도 있다. &ldquo;dist"라는 alias task는 "concat"과 "uglify"에서 "dist&rdquo; target 들만 실행한다.</p>

<p><code>javascript
grunt.registerTask('dist', ['concat:dist', 'uglify:dist']);
</code></p>

<h2>Multi Tasks</h2>

<p>Multi-task로 만든 task는 실행될 때, Grunt 환경 설정 객체에서 동명의 프로퍼티를 찾는다. 또한 multi-task는 적절한 target(task의 하위 개념) 명으로 각자의 환경설정을 가질 수 있다.</p>

<p><code>grunt concat</code>란 컴멘드가 그 안의 모든 target를 순회하는 반면에, <code>grunt concat:foo</code>나 <code>grunt concat:bar</code>처럼 task와 target까지 지정하면, 특정 target의 환경설정만 가져온다. 이때  <a href="http://gruntjs.com/grunt.task#grunt.task.renametask">grunt.task.renameTask</a>로 이름을 변경하면, 바꾼 task 명으로 환경 설정을 찾는다.</p>

<p><a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint plugin jshint task</a>와 <a href="https://github.com/gruntjs/grunt-contrib-concat">grunt-contrib-concat plugin concat task</a>같이 contrib로 시작하는 대부분의 task는 multi task다.</p>

<p><code>javascript
grunt.registerMultiTask(taskName, [description, ] taskFunction)
</code></p>

<p>다음 multi-task에서 <code>grunt log:foo</code>로 grunt를 실행하면 <code>foo: 1,2,3</code>가 로그로 찍히고, <code>grunt log:bar</code>로 grunt를 실행하면 <code>bar: hello world</code>가 찍힌다. 하지만 <code>grunt log</code>로 grunt를 실행하면 순서대로 <code>foo: 1,2,3</code>가 찍히고 <code>bar: hello world</code>가 찍힌 다음 <code>baz: false</code>가 찍힌다.</p>

<p>```javascript
grunt.initConfig({
  log: {</p>

<pre><code>foo: [1, 2, 3],
bar: 'hello world',
baz: false
</code></pre>

<p>  }
});</p>

<p>grunt.registerMultiTask(&lsquo;log&rsquo;, &lsquo;Log stuff.&rsquo;, function() {
  grunt.log.writeln(this.target + &lsquo;: &rsquo; + this.data);
});
```</p>

<h2>&ldquo;Basic&rdquo; Tasks</h2>

<p>Multi-task가 아닌 기본 task가 실행될 때는 Grunt가 환경설정을 바라보지 않는다. 지정한 task function만 실행한다. 기본 task에서는 콜론(:)로 구분한 인자 목록을 task function 함수의 전달인자로 넘길 수 있다.</p>

<p><code>javascript
grunt.registerTask(taskName, [description, ] taskFunction)
</code></p>

<p><code>grunt foo:testing:123</code>를 입력하면 <code>foo, testing 123</code>가 콘솔에 출력된다. <code>grunt foo</code>처럼 아무 인자도 넘기지 않고 실행하면 <code>foo, no args</code>가 콘솔에 찍힌다.</p>

<p>```javascript
grunt.registerTask(&lsquo;foo&rsquo;, &lsquo;A sample task that logs stuff.&rsquo;, function(arg1, arg2) {
  if (arguments.length === 0) {</p>

<pre><code>grunt.log.writeln(this.name + ", no args");
</code></pre>

<p>  } else {</p>

<pre><code>grunt.log.writeln(this.name + ", " + arg1 + " " + arg2);
</code></pre>

<p>  }
});
```</p>

<h2>Custom tasks</h2>

<p>만들려는 Task가 &ldquo;multi-task&rdquo; 구조를 따르지 않는다면 기본 task형태로 사용자 정의  task를 만들자.</p>

<p><code>javascript
grunt.registerTask('default', 'My "default" task description.', function() {
  grunt.log.writeln('Currently running the "default" task.');
});
</code></p>

<p>task 안에서 다른 task를 실행할 수 있으며,</p>

<p><code>javascript
grunt.registerTask('foo', 'My "foo" task.', function() {
  // "bar"와 "baz" task가 "foo" 가 끝난 후에 순서대로 실행하려고 대기중이다.
  grunt.task.run('bar', 'baz');
  // 이렇게 적어도 된다.
  grunt.task.run(['bar', 'baz']);
});
</code></p>

<p>비동기도 가능하다.</p>

<p>```javascript
grunt.registerTask(&lsquo;asyncfoo&rsquo;, &lsquo;My &ldquo;asyncfoo&rdquo; task.&rsquo;, function() {
  // task를 비동기 모드로 만들고 &ldquo;done&rdquo; 함수로 제어한다.
  var done = this.async();
  // 동기 작업을 실행한다.
  grunt.log.writeln(&lsquo;Processing task&hellip;&rsquo;);
  // 그리고 비동기 작업을 실행한다.
  setTimeout(function() {</p>

<pre><code>grunt.log.writeln('All done!');
done();
</code></pre>

<p>  }, 1000);
});
```</p>

<p>이렇게 만든 task도 그 이름과 인자를 사용해서 접근할 수 있다.</p>

<p>```javascript
grunt.registerTask(&lsquo;foo&rsquo;, &lsquo;My &ldquo;foo&rdquo; task.&rsquo;, function(a, b) {
  grunt.log.writeln(this.name, a, b);
});</p>

<p>// 사용법:
// grunt foo foo:bar
//   출력로그: &ldquo;foo&rdquo;, undefined, undefined
//   출력로그: &ldquo;foo&rdquo;, &ldquo;bar&rdquo;, undefined
// grunt foo:bar:baz
//   출력로그: &ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;
```</p>

<p>Task에서 에러가 발생하면 Task를 실패처리 할 수도 있다.</p>

<p>```javascript
grunt.registerTask(&lsquo;foo&rsquo;, &lsquo;My &ldquo;foo&rdquo; task.&rsquo;, function() {
  if (failureOfSomeKind) {</p>

<pre><code>grunt.log.error('에러 메세지');
</code></pre>

<p>  }</p>

<p>  // task 실행 중 에러가 있다면 false를 반환해서 실패 처리한다.
  if (ifErrors) { return false; }</p>

<p>  grunt.log.writeln(&lsquo;성공 메세지&rsquo;);
});
```</p>

<p>task가 실패하면, <code>--force</code>를 붙이지 않는한 그 이후 작업은 모두 중단된다.</p>

<p>```javascript
grunt.registerTask(&lsquo;foo&rsquo;, &lsquo;My &ldquo;foo&rdquo; task.&rsquo;, function() {
  // 동기적 실패 처리
  return false;
});</p>

<p>grunt.registerTask(&lsquo;bar&rsquo;, &lsquo;My &ldquo;bar&rdquo; task.&rsquo;, function() {
  var done = this.async();
  setTimeout(function() {</p>

<pre><code>// 비동기적 실패 처리
done(false);
</code></pre>

<p>  }, 1000);
});
```</p>

<p>Task는 다른 task가 성공적으로 실행되었는지 여부와 관련지을 수도 있다. <code>grunt.task.requires</code>는 실제로 다른 task를 실행하지는 않지만, 그 task가 실행되었는지, 실패는 없었는지를 확인한다.</p>

<p>```javascript
grunt.registerTask(&lsquo;foo&rsquo;, &lsquo;My &ldquo;foo&rdquo; task.&rsquo;, function() {
  return false;
});</p>

<p>grunt.registerTask(&lsquo;bar&rsquo;, &lsquo;My &ldquo;bar&rdquo; task.&rsquo;, function() {
  // &ldquo;foo&rdquo; task가 실패했거나 실행된적이 없다면, 이 task를 실패 처리한다.
  grunt.task.requires(&lsquo;foo&rsquo;);
  // 이 코드는 &ldquo;foo&rdquo; task가 성공적으로 실행된 적이 있을 때만 실행된다.
  grunt.log.writeln(&lsquo;Hello, world.&rsquo;);
});</p>

<p>// 사용법
// grunt foo bar
//   foo가 실패하는 task이므로 로그는 출력되지 않는다.
// grunt bar
//   foo가 실행된적이 없으므로 로그는 출력되지 않는다.
```</p>

<p><code>grunt.config.requires</code>를 사용하면, Task가 존재하지 않는 환경설정 프로퍼티를 요구할 때, 실패 처리할 수 있다.</p>

<p><code>javascript
grunt.registerTask('foo', 'My "foo" task.', function() {
  // "meta.name" 란 환경설정 프로퍼티가 없으면 이 타스트를 실패 처리한다.
  grunt.config.requires('meta.name');
  // 이경우도 "meta.name" 환경설정 프로퍼티가 없다면, 실패한다.
  grunt.config.requires(['meta', 'name']);
  // 조건이 충족되어야 로그가 출력된다.
  grunt.log.writeln('meta.name이 환경설정에 정의되어있을 때만 로그가 출력된다.');
});
</code></p>

<p>환경설정 프로퍼티에는 <code>grunt.config</code>로 접근할 수 있다.</p>

<p><code>javascript
grunt.registerTask('foo', 'My "foo" task.', function() {
  // 프로퍼티 값을 로그로 출력한다. 프로퍼티가 undefined이면 null을 반환한다.
  grunt.log.writeln('The meta.name property is: ' + grunt.config('meta.name'));
  // 이경우도 프로퍼티 값을 로그로 출력한다. 프로퍼티가 undefined이면 null을 반환한다.
  grunt.log.writeln('The meta.name property is: ' + grunt.config(['meta', 'name']));
});
</code></p>

<p>더 자세한 예제는 <a href="https://github.com/gruntjs/">contrib task</a>들을 참고하자.</p>

<h2>CLI optiosn / environment</h2>

<p>내용 없음.</p>

<h2>Why doesn&rsquo;t my asynchronous task complete?</h2>

<p>비동기 task를 짰는데 완료되지 않는다면, 대부분 <a href="http://gruntjs.com/grunt.task#wiki-this-async">this.asynce</a>를 호출하지 않았기 때문이다. 쉽게 하려면, 동기식 코딩 스타일을 사용하고 나서 task 내부에 <code>this.async()</code>를 호출해서 비동기로 변경할 수 있다.</p>

<p>그리고 다시 말하지만, <code>done()</code>에 인자로 <code>false</code>를 넘기면 Grunt에게 task가 실패했다고 알릴 수 있다.</p>

<p>예제 코드다.</p>

<p><code>javascript
grunt.registerTask('asyncme', 'My asynchronous task.', function() {
  var done = this.async();
  doSomethingAsync(done);
});
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt: Sample Gruntfile in korean]]></title>
    <link href="http://zziuni.github.io/blog/2013/11/26/grunt-sample-gruntfile-in-korean/"/>
    <updated>2013-11-26T00:31:00+09:00</updated>
    <id>http://zziuni.github.io/blog/2013/11/26/grunt-sample-gruntfile-in-korean</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://gruntjs.com">Grunt</a>은 Javascript Task Runner 입니다.. 이 문서는 Grunt 공식 사이트의 <a href="http://gruntjs.com/sample-gruntfile">Sample Gruntfile</a>를 번역한 문서이며 grunt-cli의 버전이 0.1.11일 때 번역했습니다.</p></blockquote>

<h1>Sample Gruntfile</h1>

<p>다음 다섯 개의 Grunt 플러그인을 사용하는 <code>Gruntfile</code> 샘플을 살펴보겠다.</p>

<ul>
<li><a href="https://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-qunit">grunt-contrib-qunit</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-concat">grunt-contrib-concat</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-watch">grunt-contrib-watch</a></li>
</ul>


<!-- more -->


<p>전체 <code>Gruntfile</code>은 이 페이지 가장 아래에 제공하지만, 순서대로 읽어야 단계별로 이해할 수 있다.</p>

<p>첫 부분은 Grunt 환경설정을 캡슐화하는 &ldquo;wrapper&rdquo; 함수다.</p>

<p><code>javascript
module.exports = function(grunt){
}
</code></p>

<p>이 함수안에서 환경설정 객체를 생성할 수 있다.</p>

<p><code>javascript
grunt.initConfig({
});
</code></p>

<p>다음은 <code>pkg</code>프로퍼티에 <code>package.json</code>파일의 프로젝트 설정을 읽어서 설정한다. 이를 통해서 <code>package.json</code> 파일의 프로퍼티 값들을 참조할 수 있다. 조금만 더 읽으면 볼 수 있다.</p>

<p><code>javascript
pkg: grunt.file.readJSON("package.json");
</code></p>

<p>여기까지 본 것을 합치면 이렇게 된다.</p>

<p>```javascript
module.exports = function(grunt) {
  grunt.initConfig({</p>

<pre><code>pkg: grunt.file.readJSON('package.json')
</code></pre>

<p>  });
};
```</p>

<p>이제, task 별 환경설정을 정의할 수 있다. task를 위한 환경설정 객체는 전체 환경설정 객체에서 task 명과 동일한 이름의 프로퍼티로 존재한다. 즉, &ldquo;concat&rdquo; task는 환경설정 객체의 &ldquo;concat&rdquo; 프로퍼티에 있다. 다음은 &ldquo;concat"을 위한 task 환경설정 객체의 예제다.</p>

<p>```javascript
concat: {
  options: {</p>

<pre><code>// 합친 결과 파일에서 각 파일을 구분할 문자열을 정의한다. 
separator: ';'
</code></pre>

<p>  },
  dist: {</p>

<pre><code>// 합칠 파일들.
src: ['src/**/*.js'],
// 결과 js 파일의 위치
dest: 'dist/&lt;%= pkg.name %&gt;.js'
</code></pre>

<p>  }
}
```</p>

<p><code>package.json</code>의 <code>name</code> 프로퍼티를 어떻게 참조했는지 보이는가? 우리는 <code>package.json</code>을 불러온 결과가 들어있는 <code>pkg</code> 프로퍼티를 통해서 <code>pkg.name</code>로 접근했다. 이 값은 이미 자바스크립트 객체로 파싱되어있다. Grunt는 환경설정 객체의 프로퍼티 값을 뱉어내는 탬플릿 엔진을 가지고 있다. 여기서는 <code>src/</code> 폴더에서 확장자가 <code>.js</code>인 파일 전부를 합치는 concat task를 설정했다.</p>

<p>이번에는 자바스크립트를 minify(공백을 제거하고 변수명을 짧은 이름으로 바꾸는 작업)하는 uglify 플러그인을 설정해보자.</p>

<p>```javascript
uglify: {
  options: {</p>

<pre><code>// 결과 파일 상단에 주석을 넣는다. 
banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("dd-mm-yyyy") %&gt; */\n'
</code></pre>

<p>  },
  dist: {</p>

<pre><code>files: {
  'dist/&lt;%= pkg.name %&gt;.min.js': ['&lt;%= concat.dist.dest %&gt;']
}
</code></pre>

<p>  }
}
```</p>

<p>이제 uglify task는 minify한 자바스크립트 파일을 <code>dist/</code>에 생성한다. 여기서는 concat task에서 생성한 파일을 사용해서 minify를 진행하기 위해서 <code>&lt;%= concat.dis.dest %&gt;</code>를 사용했다.</p>

<p>QUnit 플러그인은 설정이 정말 간단한다. 그냥 QUnit을 실행하는 HTML 실행 파일(test runner)이 있는 위치만 지정하면 된다.</p>

<p><code>javascript
qunit: {
  files: ['test/**/*.html']
},
</code></p>

<p>JSHint 플러그인도 정말 간단한다.</p>

<p>```javascript
jshint: {
  // 검사를 실행할 파일을 지정한다.
  files: [&lsquo;gruntfile.js&rsquo;, &lsquo;src/<strong>/*.js&rsquo;, &lsquo;test/</strong>/*.js&rsquo;],
  // JSHint 환경설정 (<a href="http://www.jshint.com/docs/">http://www.jshint.com/docs/</a> 참고)
  options: {</p>

<pre><code>// 바꾸고 싶은 JSHint 기본값을 여기 지정한다. 
globals: {
  jQuery: true,
  console: true,
  module: true
}
</code></pre>

<p>  }
}
```</p>

<p>JSHint도 파일 목록이 담긴 배열과 옵션 객체만 설정하면 된다. JSHint에 대한 정보는 <a href="http://www.jshint.com/docs/">사이트</a>를 참고한다. JSHint를 기본값으로 잘 써왔다면, Gruntfile에서 재정의 할 필요없다.</p>

<p>끝으로 watch 플러그인을 보자.</p>

<p><code>javascript
watch: {
  files: ['&lt;%= jshint.files %&gt;'],
  tasks: ['jshint', 'qunit']
}
</code></p>

<p>이 task는 컴멘드 라인에 <code>grunt watch</code>를 입력해서 실행할 수 있다. 그러면, 설정한 파일에 어떤 변화가 감지될 때, 지정한 task들을 순서대로 실행한다. (여기서는 JSHint 확인을 위해서 같은 대상파일을 사용했다.)</p>

<p>이제, 필요한 Grunt 플러그인을 불러와야 하는데, 이들은 사전에 npm을 통해서 설치되어있어야 한다.</p>

<p><code>javascript
grunt.loadNpmTasks('grunt-contrib-uglify');
grunt.loadNpmTasks('grunt-contrib-jshint');
grunt.loadNpmTasks('grunt-contrib-qunit');
grunt.loadNpmTasks('grunt-contrib-watch');
grunt.loadNpmTasks('grunt-contrib-concat');
</code></p>

<p>그리고 나서 task를 몇 개 설정한다. 가장 중요한건 default task다.</p>

<p>```javascript
// 컴멘드 라인에 &ldquo;grunt test"를 입력하면 실행된다.
grunt.registerTask(&lsquo;test&rsquo;, [&lsquo;jshint&rsquo;, &lsquo;qunit&rsquo;]);</p>

<p>// default task는 컴멘드 라인에 &ldquo;grunt"만 입력했을 때 실행할 task들이다.
grunt.registerTask(&lsquo;default&rsquo;, [&lsquo;jshint&rsquo;, &lsquo;qunit&rsquo;, &lsquo;concat&rsquo;, &lsquo;uglify&rsquo;]);
```</p>

<p>전체 <code>Gruntfile.js</code>다.</p>

<p>```javascript
module.exports = function(grunt) {</p>

<p>  grunt.initConfig({</p>

<pre><code>pkg: grunt.file.readJSON('package.json'),
concat: {
  options: {
    separator: ';'
  },
  dist: {
    src: ['src/**/*.js'],
    dest: 'dist/&lt;%= pkg.name %&gt;.js'
  }
},
uglify: {
  options: {
    banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("dd-mm-yyyy") %&gt; */\n'
  },
  dist: {
    files: {
      'dist/&lt;%= pkg.name %&gt;.min.js': ['&lt;%= concat.dist.dest %&gt;']
    }
  }
},
qunit: {
  files: ['test/**/*.html']
},
jshint: {
  files: ['Gruntfile.js', 'src/**/*.js', 'test/**/*.js'],
  options: {
    // options here to override JSHint defaults
    globals: {
      jQuery: true,
      console: true,
      module: true,
      document: true
    }
  }
},
watch: {
  files: ['&lt;%= jshint.files %&gt;'],
  tasks: ['jshint', 'qunit']
}
</code></pre>

<p>  });</p>

<p>  grunt.loadNpmTasks(&lsquo;grunt-contrib-uglify&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-jshint&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-qunit&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-watch&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-concat&rsquo;);</p>

<p>  grunt.registerTask(&lsquo;test&rsquo;, [&lsquo;jshint&rsquo;, &lsquo;qunit&rsquo;]);</p>

<p>  grunt.registerTask(&lsquo;default&rsquo;, [&lsquo;jshint&rsquo;, &lsquo;qunit&rsquo;, &lsquo;concat&rsquo;, &lsquo;uglify&rsquo;]);</p>

<p>};
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt: Configuring tasks in korean]]></title>
    <link href="http://zziuni.github.io/blog/2013/11/17/grunt-configuring-tasks-in-korean/"/>
    <updated>2013-11-17T00:29:00+09:00</updated>
    <id>http://zziuni.github.io/blog/2013/11/17/grunt-configuring-tasks-in-korean</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://gruntjs.com">Grunt</a>은 Javascript Task Runner 입니다. 이 문서는 Grunt 공식 사이트의 <a href="http://gruntjs.com/configuring-tasks">Configuring Tasks</a>를 번역한 문서이며 grunt-cli의 버전이 0.1.10일 때 번역했습니다.</p></blockquote>

<h1>Configuring tasks</h1>

<p>이 문서는 <code>Gruntfile</code>를 사용하는 프로젝트를 위해서 task 단위로 환경설정을 하는 법을 설명한다. <code>Gruntfile</code>에 대해 잘 모른다면 <a href="http://gruntjs.com/getting-started">Getting Started</a> (<a href="http://zziuni.github.io/blog/2013/10/13/grunt-getting-started-in-korean/">번역문</a>)문서를 먼저 읽어보고 <a href="http://gruntjs.com/sample-gruntfile">Gruntfile 샘플</a> 파일을 체크아웃 받자.</p>

<h2>Grunt Configuration</h2>

<p>task 환경설정은 <code>Gruntfile</code>에서 <code>grunt.initConfig</code> 메서드를 통해서 지정한다. 일반적으로 환경설정은 task 명과 동일한 프로퍼티의 값으로 설정한다. 여러분이 설정한 task의 이름들과 충돌하지만 않으면 얼마든지 임의의 데이터를 넣을 수 있다. 물론 무시되지만.</p>

<!-- more -->


<p>또한, 이 파일은 JSON이 아닌 자바스크립트 파일이기 때문에, 모든 자바스크립트 코드를 사용할 수 있다. 필요하다면 동적으로 환경설정을 생성할 수도 있다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    // concat task를 위한 환경설정은 여기에 넣는다.
  },
  uglify: {
    // uglify task를 위한 환경설정은 여기에 넣는다. 
  },
  // 특정 task와 관련없는 임의의 프로퍼티
  my_property: 'whatever',
  my_src_files: ['foo/*.js', 'bar/*.js'],
});
</code></pre>

<p>```</p>

<h2>Task Configuration and Targets</h2>

<p>task 하나가 실행되면, Grunt는 그 task의 이름으로 <code>Gruntfile</code>의 환경설정 객체에서 프로퍼티를 찾고 이를 해당 task의 환경설정으로 사용한다. 여러 일을 한 번에 하는 multi-task는 다시 별도의 target 명을 사용해서 환경설정을 개별적으로 가질 수 있다. 다음 예제를 보면 <code>uglify</code> task는 <code>bar</code> target만 가지고 있지만, <code>concat</code> task는 <code>foo</code>와 <code>bar</code>라는 두 개의 target을 갖고 있다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    foo: {
      // concat task의 "foo" 타겟을 위한 옵션과 파일을 여기에 넣는다. 
    },
    bar: {
      // concat task의 "bar" 타겟을 위한 옵션과 파일을 여기에 넣는다. 
    },
  },
  uglify: {
    bar: {
      // uglify task의 "bar" 타겟을 위한 옵션과 파일을 여기에 넣는다. 
    },
  },
});
</code></pre>

<p>```</p>

<p><code>grunt concat</code>를 입력하면 모든 target을 순회하며, 차례대로 모든 target의 환경설정을 가져오는 반면에, <code>grunt concat:foo</code>나 <code>grunt concat:bar</code>처럼 task와 target을 모두 사용해서 지정하면 특정 target의 환경설정만 가져온다. 단, task 명이 <strong>grunt.renameTask</strong>로 변경되면, Grunt는 새로운 task 명으로 config 객체에서 프로퍼티 명을 찾는다.</p>

<h2>Options</h2>

<p>task 환경설정 하나를 살펴보자, <code>options</code> 프로퍼티는 내장된 기본값을 재정의 하기 위해서 덮어 쓸 때 사용한다. 그리고 각 target 별로도 해당 target에만 한정된 <code>options</code> 프로퍼티를 가질 수 있다. target 레벨의 options는 해당 타겟 레벨에서만 덮어써진다.</p>

<p><code>options</code> 프로퍼티는 필수요소가 아니며, 필요없는 경우 무시된다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    options: {
      // task 수준의 옵션 객체. task 기본값을 덥어쓴다. 
    },
    foo: {
      options: {
        // "foo" target 수준의 옵션 객체. task 수준의 options을 덥어쓴다. 
      },
    },
    bar: {
      // 명시된 options가 없다. 이 target은 task 수준의 options을 사용한다.
    },
  },
});
</code></pre>

<p>```</p>

<h2>Files</h2>

<p>대부분의 task는 파일을 대상으로하는 작업들이므로, Grunt는 task가 작업 대상 파일을 선언하기 위한 추상화된 기능을 강력하게 지원한다. <strong>src-dest</strong>(출처와 목적지)간의 파일 매핑을 정의하는 방법은 여러 가지가 있다. 매핑의 표현과 제어도 지속적으로 변경 가능하면서 말이다.
이제부터 설명할 유형들은 모든 task에서 사용할 수 있으므로, 여러분 상황에 맞는 포맷을 선택하면 된다.</p>

<p><code>src</code>와 <code>dest</code>는 모두 파일 포맷에서 지원하지만 &ldquo;Compact"와 "Files Array&rdquo; 포맷에서는 몇 가지 추가 프로퍼티를 사용할 수 있다.</p>

<ul>
<li><code>fileter</code>: 필터용도로 유효한 <a href="http://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats">fs.Stats 메서드명</a>이나 함수를 적용한다. 이때, 함수는 적절한 <code>src</code> 파일경로를 받으면 <code>true</code>나 <code>false</code>를 반환해야 한다.</li>
<li><code>nonull</code>: <code>true</code>를 지정했을 때는 패턴과 일치하는 내용이 없는 경우, 그 패턴 자체를 담은 목록을 반환하고, <code>false</code>를 지정했을 때는 패턴과 일치하는 내용이 없는 경우, 빈 목록을 반환한다. <code>--verbos</code>와 함께 사용하면 파일 경로 관련 버그를 찾을 때 유용하다.</li>
<li><code>dot</code>: <code>true</code>면 패턴에 명시적으로 포함시키지 않아도 구두점(.)으로 시작하는 파일명을 일치시킨다.(src/*.js 하면 hidden files도 포함된다는 말.)</li>
<li><code>matchBase</code>: <code>true</code>면, 슬래시(/)를 포함하지 않은 패턴들이 슬래시를 가지고 있을 경로 기본명을 제외하고 매치된다. 예를 들어 <code>a?b</code> 패턴이 <code>/xyz/acb/123</code>이 아니라 <code>/xyz/123/acb</code>와 일치한다.</li>
<li><code>expand</code>은 동적인 src-dest 파일 매핑을 수행한다. 더 자세한 정보는 <a href="http://gruntjs.com/configuring-tasks#building-the-files-object-dynamically">Building the files object dynamically</a>를 참고한다.</li>
<li>이 이외의 프로퍼티들은 매칭 옵션으로 하위 libs로 전달된다. 추가 옵션은 <a href="https://github.com/isaacs/node-glob">node-glob</a>와 <a href="https://github.com/isaacs/minimatch">minimatch</a>를 보자.</li>
</ul>


<h3>Compact Format</h3>

<p>이 형태는 target 별로 단일 <strong>src-dest</strong> 파일 매핑을 할 때 사용한다. 주로 <a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint</a>처럼 <code>dest</code>와 관계없이 <code>src</code> 프로퍼티 하나만 필요한 읽기 전용 task를 위해서 사용한다. src-dest 파일 매핑 별로 프로퍼티 확장도 가능하다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  jshint: {
    foo: {
      src: ['src/aa.js', 'src/aaa.js']
    },
  },
  concat: {
    bar: {
      src: ['src/bb.js', 'src/bbb.js'],
      dest: 'dest/b.js',
    },
  },
});
</code></pre>

<p>```</p>

<h3>Files Object Format</h3>

<p>이 형태는 target 별로 다중 src-dest 매핑을 할 때 사용한다. 프로퍼티 명이 목적지(destination) 파일명이고 프로퍼티 값은 출처(source) 파일이 된다. 이 방법을 사용하면 src-dest 파일 매핑이 아무리 많아도 지정할 수 있다. 하지만 매핑 별로 추가 파라미터 지정은 불가능하다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    foo: {
      files: {
        'dest/a.js': ['src/aa.js', 'src/aaa.js'],
        'dest/a1.js': ['src/aa1.js', 'src/aaa1.js'],
      },
    },
    bar: {
      files: {
        'dest/b.js': ['src/bb.js', 'src/bbb.js'],
        'dest/b1.js': ['src/bb1.js', 'src/bbb1.js'],
      },
    },
  },
});
</code></pre>

<p>```</p>

<h3>Files Array Format</h3>

<p>이 형태는 target 별로 다중 src-dest 매핑을 지원하면서 매핑 별로 추가 프로퍼티를 사용할 수 있다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    foo: {
      files: [
        {src: ['src/aa.js', 'src/aaa.js'], dest: 'dest/a.js'},
        {src: ['src/aa1.js', 'src/aaa1.js'], dest: 'dest/a1.js'},
      ],
    },
    bar: {
      files: [
        {src: ['src/bb.js', 'src/bbb.js'], dest: 'dest/b/', nonull: true},
        {src: ['src/bb1.js', 'src/bbb1.js'], dest: 'dest/b1/', filter: 'isFile'},
      ],
    },
  },
});
</code></pre>

<p>```</p>

<h3>Older Formats</h3>

<p><strong>dest as targets</strong> 파일 형태는 멀티 task와 target가 있기 전부터 있던 형태로 목적지(destination) 파일 경로가 그대로 target 명이 된다. 하지만 이 때문에 <code>grunt task:target</code>의 형태로 동작시키기가 거북할 수 있다. 또한 src-dest 매핑 별로 target 수준의 옵션이나 추가 프로퍼티를 지정할 수 없다.</p>

<p>이 형태는 되도록 사용하지 말고 가능하면 피하자.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    'dest/a.js': ['src/aa.js', 'src/aaa.js'],
    'dest/b.js': ['src/bb.js', 'src/bbb.js'],
  },
});
</code></pre>

<p>```</p>

<h3>Custom Filter Function</h3>

<p><code>filter</code> 프로퍼티를 사용하면 파일을 좀 더 꼼꼼하게 지정할 수 있다. 그냥 적절한 <a href="http://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats">fs.Stats 메서드명</a>을 사용하자. 다음 예제는 패턴과 일치하는 파일만 제거(clean)한다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  clean: {
    foo: {
      src: ['tmp/**/*'],
      filter: 'isFile',
    },
  },
});
</code></pre>

<p>```</p>

<p>아니면 파일 일치 여부에 따라 <code>true</code>, <code>false</code>를 반환하는 <code>filter</code>용 함수를 생성하자. 다음 예제는 빈 폴더만 지우는 필터다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  clean: {
    foo: {
      src: ['tmp/**/*'],
      filter: function(filepath) {
        return (grunt.file.isDir(filepath) &amp;&amp; require('fs').readdirSync(filepath).length === 0);
      },
    },
  },
});
</code></pre>

<p>```</p>

<h3>Globbing patterns</h3>

<p>대상(source) 파일 경로를 모두 개별적으로 지정하는 일이 불가능할 때도 있다. 그래서 Grunt는 <a href="https://github.com/isaacs/node-glob">node-glob</a>와 <a href="https://github.com/isaacs/minimatch">minimatch</a>라이브러리를 내부에 포함시켰고, 이를 통해서 파일명 확장을 지원한다. (globbing이라고도 한다.)</p>

<p>이 문서는 globbing 패턴 전반을 다루는 튜토리얼이 아니므로, 파일경로에서 사용할 수 있는 몇 가지만 소개한다.</p>

<ul>
<li><code>*</code>는 개수와 관계없이 <code>/</code>를 제외한 모든 캐릭터와 일치한다.</li>
<li><code>?</code>는 <code>/</code>를 제외한 하나의 캐릭터와 일치한다.</li>
<li><code>**</code>는 개수와 관계없이 <code>/</code>를 포함한 모든 캐릭터와 일치한다. 하지만 경로부분(폴더명)에서만 동작한다.</li>
<li><code>{}</code>에 콤마로 구분된 목록을 넣으면 &ldquo;or&rdquo; 표현식으로 동작한다.</li>
<li><code>!</code>를 패턴의 처음에 사용하면 불일치(negative match)를 의미한다.</li>
</ul>


<p>globbing 패턴을 잘 모르더라도 <code>foo/*.js</code>는 <code>foo/</code> 폴더에서 <code>.js</code>로 끝나는 모든 파일과 일치하지만, <code>foo/**/*.js</code>는 <code>foo/</code> 폴더와 그 아래의 모든 하위 폴더에서 <code>.js</code>로 끝나는 모든 파일과 일치한다는 것 정도는 알아두면 좋다.</p>

<p>globbing 패턴의 복잡함을 줄이기 위해서, Grunt에서는 파일 경로나 globbing 패턴을 배열로 지정할 수 있다. 패턴은 모두 배열의 색인 순서대로 처리되는데, 결과 집합에서 일치하는 파일을 제외하는 <code>!</code> 접두사 패턴도 마찬가지다. 최종 결과 집합은 중복값이 없는 유일값들이다.</p>

<p>예제을 보자.</p>

<p>```javascript</p>

<pre><code>// 단일 파일 지정. 
{src: 'foo/this.js', dest: ...}
// 배열로 여러 파일 지정.
{src: ['foo/this.js', 'foo/that.js', 'foo/the-other.js'], dest: ...}
// glob 패턴 사용.
{src: 'foo/th*.js', dest: ...}

// 단일 node-glob 패턴.
{src: 'foo/{a,b}*.js', dest: ...}
// 물론 이렇게도 사용 가능.
{src: ['foo/a*.js', 'foo/b*.js'], dest: ...}

// foo/ 안의 모든 .js 파일. 순서는 알파벳 순.
{src: ['foo/*.js'], dest: ...}
// bar.js을 먼저 선택하고, 남은 파일을 알파벳 순으로 추가.
{src: ['foo/bar.js', 'foo/*.js'], dest: ...}

// bar.js를 제외한 모든 파일. 알파벳 순.
{src: ['foo/*.js', '!foo/bar.js'], dest: ...}
// 모든 파일을 알파벳 순서로 넣고, 끝에 bar.js를 추가.
{src: ['foo/*.js', '!foo/bar.js', 'foo/bar.js'], dest: ...}

// 파일경로나 glob 패턴에 템플릿(&lt;%%&gt;)을 사용할 수도 있다.
{src: ['src/&lt;%= basename %&gt;.js'], dest: 'build/&lt;%= basename %&gt;.min.js'}
// 환경설정의 다른 task의 target에서 정의한 파일 목록을 참조할 수도 있다.
{src: ['foo/*.js', '&lt;%= jshint.all.src %&gt;'], dest: ...}
</code></pre>

<p>```</p>

<p>더 자세한 glob 패턴 문법은 <a href="https://github.com/isaacs/node-glob">node-glob</a>와 <a href="https://github.com/isaacs/minimatch">minimatch</a> 문서를 참고하자.</p>

<h3>Building the fiels object dynamically</h3>

<p>대량의 파일들을 처리하고자 할 때, 파일 목록을 동적으로 생성하는데 사용가능한 몇 가지 추가 프로퍼티들이 있다. 이 프로퍼티들은 &ldquo;Compact"와 "Files Array&rdquo; 매핑 패턴에 지정할 수 있다.</p>

<ul>
<li><code>expand</code>: 다음 옵션들을 활성화하려면 먼저 이 프로퍼티를 <code>true</code>로 설정한다.</li>
<li><code>cwd</code>: 모든 <code>src</code> 패턴을 이 옵션에 정의된 경로를 기준으로 정한다.</li>
<li><code>src</code>: 일치 여부 확인을 위한 패턴 목록. <code>cwd</code>기준 상대경로.</li>
<li><code>dest</code>: 목적지 지정을 위한 경로 접두사.</li>
<li><code>ext</code>: <code>dest</code> 경로에 생성할 파일의 확장자.</li>
<li><code>flatten</code>: <code>dest</code> 경로에 생성할 목록에서 경로부분을 제거하고 파일명만 남긴다.</li>
<li><code>rename</code>: 일치하는 <code>src</code> 파일별로 호출되는 함수. 이 함수는 (확장자 변경과 경로 제거 후) 일치하는 <code>src</code> 패턴과 <code>dest</code>를 인자로 받아서, 새로운 <code>dest</code> 값을 반환해야 한다. 동일 <code>dest</code> 값이 여러 번 반환되면, 사용된 <code>src</code>들이 이름변경을 위한 출처 배열에 추가된다.</li>
</ul>


<p>다음 <code>minify</code> task 예제는 <code>static_mappings</code>와 <code>dynamic_mappings</code> target에서 동일한 src-dest 파일 매핑을 바라보고 있다. task를 실행하면, Grunt는 자동으로 <code>dynamic_mappings</code> 파일 목록을 정적인 4개의 src-dest 파일 매핑으로 바꾼다.</p>

<p>또한, 정적인 매핑과 동적인 매핑은 다양한 방법으로 함께 쓸 수 있다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  minify: {
    static_mappings: {
      // 이 src-dest 파일 매핑은 수동으로 지정했기 때문에, 
      // 파일 추가 삭제와 Grunfile 수정을 매번 해줘야 한다.
      files: [
        {src: 'lib/a.js', dest: 'build/a.min.js'},
        {src: 'lib/b.js', dest: 'build/b.min.js'},
        {src: 'lib/subdir/c.js', dest: 'build/subdir/c.min.js'},
        {src: 'lib/subdir/d.js', dest: 'build/subdir/d.min.js'},
      ],
    },
    dynamic_mappings: {
      // "minify" task가 실행되면 Grunt는 "lib/" 아래에서 "**/*.js"를 찾는다. 
      // 그렇게 찾은 src-dest 파일 매핑으로 빌드한다. 
      // 파일이 추가/제거 될 때 마다 Gruntfile을 수정할 필요없다.
      files: [
        {
          expand: true,     // 동적 기술법을 활성화.
          cwd: 'lib/',      // Src 패턴의 기준 폴더.
          src: ['**/*.js'], // 비교에 사용할 패턴 목록.
          dest: 'build/',   // 목적 경로의 접두사(사실상 폴더명)
          ext: '.min.js',   // dest의 파일들의 확장자.
        },
      ],
    },
  },
});
</code></pre>

<p>```</p>

<h2>Templates</h2>

<p><code>&lt;%%&gt;</code> 구분자를 사용한 템플릿은 task가 해당 환경설정을 읽어올 때 자동으로 정적인 값으로 기술된다. 그리고 이는 템플릿를 모두 기술될 때 까지 재귀적으로 실행된다.</p>

<p><code>grunt.initConfig()</code>의 환경설정 객체는 프로퍼티 설정시 컨텍스트로 사용되며, <code>grunt</code>와 그 메서드도 그 안에서 사용할 수 있다. 예) <code>&lt;%= grunt.template.today('yyyy-mm-dd') %&gt;</code></p>

<ul>
<li><code>&lt;%= prop.subprop%&gt;</code>는 환경설정 객체에서 <code>prop.subprop</code>을 찾아서 그 값으로 치환된다. 타입은 관계없다. 이같은 템플릿은 문자열 만이 아니라 배열과 다른 객체로 참조할 수도 있다.</li>
<li><code>&lt;% %&gt;</code>는 임의의 인라인 자바스크립트 코드를 실행한다. 그래서 흐름제어나 순회를 위해 사용할 수 있다.</li>
</ul>


<p>여기 <code>concat</code> task가 있다. <code>grunt concat:sample</code>을 실행하면 <code>foo/*.js</code> + <code>bar/*.js</code> + <code>baz/*.js</code>와 일치하는 파일을 합치고 <code>/* abcde */</code> 상단 주석(banner)를 추가해서 <code>build/abcde.js</code>란 이름으로 생성한다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    sample: {
      options: {
        banner: '/* &lt;%= baz %&gt; */\n',   // '/* abcde */\n'
      },
      src: ['&lt;%= qux %&gt;', 'baz/*.js'],  // [['foo/*.js', 'bar/*.js'], 'baz/*.js']
      dest: 'build/&lt;%= baz %&gt;.js',      // 'build/abcde.js'
    },
  },
  // task 환경설정 템플릿에 사용되는 임의의 프로퍼티들
  foo: 'c',
  bar: 'b&lt;%= foo %&gt;d', // 'bcd'
  baz: 'a&lt;%= bar %&gt;e', // 'abcde'
  qux: ['foo/*.js', 'bar/*.js'],
});
</code></pre>

<p>```</p>

<h2>Importing External Data</h2>

<p>다음 <code>Gruntfile</code> 파일은 <code>package.json</code> 파일에서 프로젝트 관련 메타데이터를 가져온다. 그리고 그 메타데이터를 <a href="http://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify 플러그인</a>의 <code>uglify</code> task의 상단 주석 생성과 src 파일 minify를 위한 정보로 사용한다.</p>

<p>Grunt는 JSON과 YAML 데이터를 가져올 수 있는 <code>grunt.file.readJSON</code>와 <code>grunt.file.readYAML</code>를 지원한다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  pkg: grunt.file.readJSON('package.json'),
  uglify: {
    options: {
      banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'
    },
    dist: {
      src: 'src/&lt;%= pkg.name %&gt;.js',
      dest: 'dist/&lt;%= pkg.name %&gt;.min.js'
    }
  }
});
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt: Getting started in korean]]></title>
    <link href="http://zziuni.github.io/blog/2013/10/13/grunt-getting-started-in-korean/"/>
    <updated>2013-10-13T00:01:00+09:00</updated>
    <id>http://zziuni.github.io/blog/2013/10/13/grunt-getting-started-in-korean</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://gruntjs.com">Grunt</a>은 Javascript Task Runner 입니다. 이 문서는 Grunt 공식 사이트의 <a href="http://gruntjs.com/getting-started">Getting Started</a>를 번역한 문서이며 grunt-cli의 버전이 0.1.7일 때 번역했습니다.</p></blockquote>

<h1>Getting started</h1>

<p><img src="http://gruntjs.com/img/grunt-logo.svg" alt="" /></p>

<p>Grunt와 Grunt 플러그인의 설치와 관리는 <a href="https://npmjs.org">npm</a>을 통해서 한다. npm은 <a href="http://nodejs.org">Node.js</a>의 패키지 메니징 도구다.</p>

<p>Grunt 0.4.x를 사용하려면 Node.js 버전이 <code>&gt;=0.8.0</code> 이여야 한다.</p>

<h2>Installing the CLI</h2>

<p><strong>Grunt 0.3을 이미 사용하고 있고 0.4.x로 업그레이드 하는 거라면, <a href="http://gruntjs.com/getting-started#grunt-0.3-notes">Grunt 0.3 Notes</a> 문서를 먼저 보자.</strong></p>

<p>Grunt를 사용하려면 먼저 Grunt&rsquo;s Command line interface (CLI)를 설치해야 한다. 이때 OSX나 nix, BSD에서는 sudo가, 윈도우즈에서는 administrator 권한이 필요할 수도 있다.</p>

<pre><code>npm install -g grunt-cli
</code></pre>

<p><code>grunt-cli</code>를 설치하면 여러분의 시스템 경로에 자동으로 <code>grunt</code>를 추가해서, 어느 디렉토리에서나 <code>grunt</code>를 사용할 수 있게 만든다.</p>

<!-- more -->


<p>하지만 <code>grunt-cli</code>는 Grunt task runner(즉, <code>grunt</code>)를 설치하지는 않는다. Grunt CLI의 역할은 간단하다. <code>Gruntflie</code>라는 파일이 있는 위치에 설치된 Grunt를 실행하는 것이다. 즉, 같은 장비에서 여러 버전의 Grunt를 설치할 수 있다.</p>

<h2>How the CLI works</h2>

<p><code>grunt</code>를 실행하면 grunt-cli는 node의 <code>require()</code>를 사용해서 프로젝트 로컬의 grunt를 실행한다. 그러므로 프로젝트 루트 폴더가 아니여도 하위 폴더 어디서든 <code>grunt</code>를 실행할 수 있다.</p>

<p>특정 위치에 설치된 Grunt를 찾으면, CLI는 Grunt 라이브러리의 로컬 인스톨본을 불러온다. 이때 <code>Gruntfile</code>라는 파일로 환경설정을 적용하고, 특정 동작을 위해 설정한 task들을 실행한다.</p>

<p>이때 일어라는 일이 궁금하면 <a href="https://github.com/gruntjs/grunt-cli/blob/master/bin/grunt">코드</a>를 읽어보자. 겁나 짧다.</p>

<h2>Preparing a new grunt project</h2>

<p>일반적인 설치과정에서는 프로젝트에 <code>package.json</code>과 <code>Grunfile</code>라는 파일이 있어야 한다.</p>

<p><strong>package.json</strong>: 이 파일은 <a href="https://npmjs.org/">npm</a>이 해당 프로젝트를 npm 모듈로 퍼블리싱할 때 사용하는 메타데이터 저장 파일이다. 이 파일의 <a href="https://npmjs.org/doc/json.html#devDependencies">devDependencies</a> 항목에 프로젝트에 필요한 grunt와 Grunt 플러그인들을 나열할 수 있다.</p>

<p><strong>Gruntfile</strong>: 이 파일의 이름은 <code>Gruntfile.js</code>이거나 <code>Gruntfile.coffee</code>이다. task를 설정하거나 정의하고 Grunt 플러그인을 불러오는데 사용한다.</p>

<h3>package.json</h3>

<p><code>package.json</code>파일은 <code>Gruntfile</code>과 함께 프로젝트 루트 디렉토리에 있어야 하고, 프로젝트 소스와 함께 커밋(commit)되야 한다. <code>package.json</code>이 있는 폴더에서 컴맨드 명령어 <code>npm install</code>를 실행하면 이 파일 안에 있는 dependency 목록의 모듈들을 해당 버전으로 인스톨한다.</p>

<p>프로젝트에 <code>package.json</code>를 추가하는 방법은 여러가지가 있다.</p>

<ul>
<li>대부분의 <a href="http://gruntjs.com/project-scaffolding#h5o-9">grunt-init</a> 템플릿은 자동으로 프로젝트 전용  <code>package.json</code>파일을 생성한다.</li>
<li><a href="https://npmjs.org/doc/init.html">npm init</a> 컴맨드 명령어는 기본 <code>package.json</code>을 생성한다.</li>
<li>다음 예제를 기초로 필요한 부분은 <a href="https://npmjs.org/doc/json.html">specification</a> 문서를 참고 해서 확장한다.</li>
</ul>


<p>```javascript</p>

<pre><code>{
  "name": "my-project-name",
  "version": "0.1.0",
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-contrib-jshint": "~0.6.3",
    "grunt-contrib-nodeunit": "~0.2.0",
    "grunt-contrib-uglify": "~0.2.2"
  }
}
</code></pre>

<p>```</p>

<h4>Installing Grunt and gruntplugins</h4>

<p>Grunt와 플러그인을 설치와 동시에 <code>package.json</code>와 연동시키려면 <code>npm install &lt;module&gt; --save-dev</code> 컴맨드 명령어를 사용한다. 이러면 <code>&lt;module&gt;</code>만 설치하고 끝나지 않고, 자동으로 <code>package.json</code>의 <a href="https://npmjs.org/doc/json.html#devDependencies">devDependencies</a> 항목에 추가된다. 버전은 <a href="https://npmjs.org/doc/json.html#version">tiled version range</a>를 사용한다.</p>

<p>예를 들면, 다음 컴맨드 명령어는 프로젝트에 Grunt 최신버전을 설치하고 <code>package.json</code>의 devDependencies 항목에 grunt를 추가한다.</p>

<pre><code>npm install grunt --save-dev
</code></pre>

<p>grunt 플러그인과 다른 node 모듈도 마찬가지다. 이렇게 설치하면 프로젝트의 <code>package.json</code>이 갱신된다.</p>

<h3>The Gruntfile</h3>

<p><code>Gruntfile.js</code>나 <code>Gruntfile.coffee</code>파일은 프로젝트 루트 폴더에 있어야 하는 자바스크립트 혹은, 커피스크립트 파일이다. 그리고 이 파일은 프로젝트 소스의 일부로 같이 커밋되야 한다.</p>

<p>다음은 <code>Gruntfile</code>의 내부 구성요소다.</p>

<ul>
<li>&ldquo;wrapper&rdquo; 함수.</li>
<li>프로젝트와 task의 환경설정.</li>
<li>grunt plugin과 task 로딩.</li>
<li>사용자 정의 task</li>
</ul>


<h4>An sample Gruntfile</h4>

<p>다음 <code>Gruntfile</code>은 프로젝트의 메타데이터를 <code>package.json</code>에서 가져와서 Grunt config로 주입한다. 그리고 <a href="http://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a> 플러그인의 <code>uglify</code> task을 사용해서 소스코드를 미니파이(minify)하도록 설정하고, 메타데이터를 이용해서 동적인 베너 주석도 생성한다. 그리고 <code>uglify</code> task를 컴맨드 라인에서 <code>grunt</code> 명령어를 실행할 때 실행되는 기본 task로 지정했다.</p>

<p>```javascript</p>

<pre><code>module.exports = function(grunt) {

  // Project configuration.
  grunt.initConfig({
    pkg: grunt.file.readJSON('package.json'),
    uglify: {
      options: {
        banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'
      },
      build: {
        src: 'src/&lt;%= pkg.name %&gt;.js',
        dest: 'build/&lt;%= pkg.name %&gt;.min.js'
      }
    }
  });

  // Load the plugin that provides the "uglify" task.
  grunt.loadNpmTasks('grunt-contrib-uglify');

  // Default task(s).
  grunt.registerTask('default', ['uglify']);

};
</code></pre>

<p>```</p>

<p>이 코드가 <code>Grunfile</code> 전체 코드다. 파트별로 살펴보자.</p>

<h4>The &ldquo;wrapper&rdquo; function</h4>

<p>모든 <code>Gruntfile</code>(그리고 그 플러그인)은 래퍼(wrapper) 함수를 기본 형태로 사용한다. 모든 Grunt 코드는 이 함수 안쪽에 있어야 한다.</p>

<p>```javascript</p>

<pre><code>module.exports = function(grunt){
    // Do grunt-related things in here
}
</code></pre>

<p>```</p>

<h4>Project and task configuration</h4>

<p>대부분의 Grunt task는 configuration을 위한 데이터로 <a href="http://gruntjs.com/grunt#grunt.initconfig">grunt.initConfig</a> 메서드의 인자로 전달되는 객체를 사용한다.(이를 configuraton 객체라 하자.)</p>

<p>위의 예제에서, <code>grunt.file.readJSON('package.json')</code> 코드는 grunt config로 <code>package.json</code>에 저장된 JOSN 메타데이터를 인포트한다. 그러면 <code>&lt;% %&gt;</code> 템플릿 문자열을 사용해서 config의 모든 프로퍼티를 참조할 수 있다.(<code>package.json</code>값을 불러올 수 있다는 말이다.) 파일패스나 파일 목록 같은 configuration 데이터는 반복을 줄이기 위해서 이 방법으로 지정한다.</p>

<p>여러분의 task가 필요로하는 프로퍼티와 충돌하지 않는 이상 configuraton 객체안에는 어떤 값을 넣어도 상관없다. 그리고 이 파일은 단순 JSON이 아닌 자바스크립트 파일이므로, 유효한 JS코드는 모두 사용가능하다. 즉, 필요한 configuration을 동적으로 생성할 수도 있다.</p>

<p>다른 task도 마찬가지지만, <a href="http://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a> 플러그인의 <code>uglify</code> task는 configuration 객체에서 동명의 프로퍼티 명(uglify)으로 설정에 필요한 값을 찾는다. 여기서는 옵션값인 <code>banner</code>와 소스파일(src) 하나를 타겟파일(dest) 하나로 미니파이(minify)하는 어그리파이(uglify) 타겟명인 <code>build</code>를 지정했다.</p>

<p>```javascript</p>

<pre><code>// Project configuration.
grunt.initConfig({
  pkg: grunt.file.readJSON('package.json'),
  uglify: {
    options: {
      banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'
    },
    build: {
      src: 'src/&lt;%= pkg.name %&gt;.js',
      dest: 'build/&lt;%= pkg.name %&gt;.min.js'
    }
  }
});
</code></pre>

<p>```</p>

<h4>Loading grunt plugins and tasks</h4>

<p>자주 사용하는 <a href="https://github.com/gruntjs/grunt-contrib-concat">concatenation</a>, <a href="http://github.com/gruntjs/grunt-contrib-uglify">minification</a>, <a href="https://github.com/gruntjs/grunt-contrib-jshint">linting</a>같은 task들은 <a href="https://github.com/gruntjs">grunt plugin</a>으로 설정해서 사용할 수 있다. 즉, <code>package.json</code>의 dependency에 플러그인을 설정했다면, <code>npm install</code>을 통해서 이미 설치된 것이므로, 간단한 코드 추가로 <code>Gurntfile</code>에서 사용 가능하다.</p>

<p>```javascript</p>

<pre><code>// Load the plugin that provides the "uglify" task.
grunt.loadNpmTasks('grunt-contrib-uglify');
</code></pre>

<p>```</p>

<p><strong>참고</strong>: <code>grunt --help</code> 명령어를 사용하면 사용가능한 taks 목록을 볼 수 있다.</p>

<h4>Custom tasks</h4>

<p><code>default</code> task를 설정하면 기본으로 실행할 task를 하나 혹은 그 이상 지정할 수 있다. 예를 들면, 컴맨드 라인에 특정 task를 지정하지 않고 <code>grunt</code>만 입력하면 <code>uglify</code> task가 실행된다. 이는 실제로는 <code>grunt uglify</code>나 <code>grunt default</code>와 같다. 배열 안에는 다수의 task를 지정할 수도 있다. (아규먼트는 있을 수도 있고 없을 수도 있다.)</p>

<p>```javascript</p>

<pre><code>// Default task(s)
grunt.registerTask('default', ['uglify']);
</code></pre>

<p>```</p>

<p>만약 프로젝트에서 Grunt 플러그인 목록에 없는 task가 필요하다면, <code>Gruntfile</code>에 직접 custom task를 만들 수도 있다. 예를 들면, 다음 <code>Gruntfile</code>은 task configuration을 전혀 활용하지 않는 custom <code>default</code> task를 정의한다.</p>

<p>```javascript</p>

<pre><code>module.exports = function(grunt){

      // A very basic default task.
      grunt.registorTask('default', 'Long some stuff', function() {
          grunt.log.write('Logging some stuff...').ok();
      });
};
</code></pre>

<p>```</p>

<p>프로젝트 전용 task라면 <code>Gruntfile</code>안에 정의할 필요없이. 별도의 <code>.js</code> 파일로 정의하고 <a href="http://gruntjs.com/grunt#grunt.loadtasks">grunt.loadTask</a> 메서드로 불러와도 된다.</p>

<h3>Further Reading</h3>

<ul>
<li><a href="http://gruntjs.com/installing-grunt/">Installing grunt</a> 가이드는 인스톨 스펙, 프로덕션, 개발, Grunt와 grunt-cli의 버전에 대한 상세한 정보를 제공한다.</li>
<li><a href="http://gruntjs.com/configuring-tasks/">Configuring Tasks</a> 가이드는 <code>Gruntfile</code>에서 task, target, option, file을 설정하는 방법을 상세하게 설명한다. tempaltes, globbing pattern, importing external data도 설명한다.</li>
<li><a href="http://gruntjs.com/creating-tasks/">Creating Tasks</a> 가이드에는 Grunt task의 타입간의 차이점 목록이 있으며, task와 configuration의 샘플도 제공한다.</li>
<li>custom task나 Grunt 플러그인에 대한 더 많은 정보는 <a href="http://gruntjs.com/grunt">developer documentation</a>을 확인하자.</li>
</ul>


<h3>Grunt 0.3 Notes</h3>

<p>Grunt 0.3에서 업그레이드 할거라면 전역 <code>grunt</code>를 제거해야 한다.</p>

<p>```javascript</p>

<pre><code>npm install -g grunt
</code></pre>

<p>```</p>

<p><em>이 안내서는 Grunt 0.4.x를 위해 작성되었다. 그렇다고 Grunt 0.3.x에서 참고할 수 없는건 아니다. 다만, &ldquo;The Gruntfile"절의 플러그인 명과 task configuration 옵션은 다를 수 있다.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build a simple client-side MVC app with RequireJS in korean]]></title>
    <link href="http://zziuni.github.io/blog/2013/10/12/build-a-simple-client-side-mvc-app-with-requirejs-in-korean/"/>
    <updated>2013-10-12T21:48:00+09:00</updated>
    <id>http://zziuni.github.io/blog/2013/10/12/build-a-simple-client-side-mvc-app-with-requirejs-in-korean</id>
    <content type="html"><![CDATA[<blockquote><p>이 글은 @verekia 씨가 작성한 <a href="http://verekia.com/requirejs/build-simple-client-side-mvc-app-require-js">Build a simple client-side MVC app with RequireJS</a>를 허락을 받아 번역한 글입니다.</p></blockquote>

<p>웹 개발자라면 흔히 파일 하나로 자바스크립트 코드를 짜기 시작합니다. 그리고 그 코드가 점점 커져서 나중에는 수정하기가 정말 어려워지죠. 이런 문제의 해결하기 위해서 코드를 여러 파일로 쪼갤 수 있습니다.  하지만 그러면 script 태그가 많아지고 다른 파일에서 정의한 함수를 조회하기 위한 글로벌 변수가 많아집니다. 그래서 글로벌 네임스페이스는 지저분해지고, 추가한 js 파일들의 HTTP 요청이  네트워크 대역폭을 차지해서 정작 해당 페이지는 로딩이 느려집니다.</p>

<p>이런 일을 겪었다면 프런트 앤드 코드를 뭔가 다른 방법으로 관리해야 겠다는 필요성을 느끼게 됩니다. 특히 자바스크립트가 수천 라인이 넘는 대형 사이즈의 웹 앱을 제작해야 한다면 더욱 그렇습니다. 유지보수를 쉽게 할 수 있도록 이 모든 문제를 해결할 새로운 방법이 필요합니다. <strong>스크립트 로더</strong>가 바로 이를 위한 새로운 기법입니다. 스크립트 로더들은 웹에서 쉽게 찾을 수 있지만 여기서는 그중에서도 <strong>RequireJS</strong>라는 라이브러리를 보겠습니다.</p>

<p>여러분은 단계별로 따라 하는 튜토리얼을 통해서 RequireJS 기반의 간단한  MVC(Model &ndash; View &ndash; Controller) 앱 제작법을 배울 겁니다. 스크립트 로더에 대한 사전 지식은 필요 없습니다. 이제 기초부터 살펴 봅시다.</p>

<!-- more -->


<h2>개 요</h2>

<h3>RequestJS란 무엇이고  왜 좋은가</h3>

<p>RequireJS는 <a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a>(Asynchronous Module Definition)의 구현체입니다. AMD란 모듈을 정의하는 방법과 모듈이 필요할 때 비동기로 로딩하는 방법을 정의한 API 입니다. <a href="https://twitter.com/#!/jrburke">제임스 버크(James Burke)</a>씨가 개발했는데, 2년간 개발해서 겨우 버전 1.0을 찍었습니다. 여러분은 RequireJS로 Javascript코드를 모듈화 할 수 있고  비동기로 관리하면서 여러파일을 병렬로 다운로드 할 수 있습니다. 스크립트 파일이 필요할 때만 병렬로 로딩되기 때문에, 페이지 로딩 속도는 빨라집니다. 그래서 이게 대단한거죠!</p>

<h3>프런트 앤드를 위한 MVC?</h3>

<p>MVC는 서버 사이트 코드를 구조화하고 모듈로 만들며 유지보수가 용의하도록 돕는 매우 잘 알려진 <strong>디자인 패턴</strong>입니다. 그러면 프런트 앤드에서 MVC를 사용하려면 어떻게 해야 할까요? 자바스크립트에서 이 디자인패턴을 적용할 수 있을 까요? 만약 여러분이 자바스크립트를 단지 애니메이션과 폼 유효성 검사, 100라인이 넘지 않는 간단한 처리를 위해서 사용한다면 MVC를 사용해서 여러분의 스크립트 파일을 구조화할 필요 없습니다. RequireJS도 사용할 필요 없을 겁니다. 하지만, 뷰(view)가 많은 리치 웹 앱을 제작 중이라면 반드시 필요합니다!</p>

<h3>우리가 만들어 볼 앱</h3>

<p>RequireJS를 사용해서 MVC 코드로 구조화하는 감을 잡기 위해서 뷰가 딱 2개인 정말 간단한 앱을 만들어 보겠습니다.</p>

<ul>
<li>사용자 목록을 보여주는 뷰. (name 속성으로 나타낸)</li>
<li>사용자를 추가할 수 있는 뷰.</li>
</ul>


<p>다음은 완성된 모습입니다.</p>

<p>![] (<a href="http://farm8.staticflickr.com/7092/7350164136_ff1c1375a3.jpg">http://farm8.staticflickr.com/7092/7350164136_ff1c1375a3.jpg</a>)</p>

<p>비즈니스 로직이 정~말 간단하기 때문에 여러분은 다른건 신경쓰지 않고 코드 구조화를 이해하는데만  집중 할 수 있습니다. 또한 이 튜토리얼을 읽으면서 같이 짜보기를 강력히 추천합니다. 진짜 간단하거든요. 오래걸리지 않습니다. 여러분이 모듈화 프로그래밍을 해본적이 없거나 RequireJS를 사용해본 적이 없다면,  프로그래밍 실력을 늘리는데 도움이 될겁니다. 후회 안 할테니 꼭 해보세요.</p>

<h3>HTML과 CSS 파일</h3>

<p>예제에서 사용할 HTML 마크업입니다.</p>

<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;A simple MVC structure&lt;/title&gt;
    &lt;link rel="stylesheet" href="css/style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="container"&gt;
        &lt;h1&gt;My users&lt;/h1&gt;
        &lt;nav&gt;&lt;a href="#list"&gt;List&lt;/a&gt; - &lt;a href="#add"&gt;Add&lt;/a&gt;&lt;/nav&gt;
        &lt;div id="app"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script data-main="js/main" src="js/require.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><code>nav</code> 메뉴의 링크는 모든 페이지에서 유지할 앱의 네이게이션이고 <code>#app</code> div에서  MVC 애플리케이션의 마술이 일어납니다. <code>body</code> 끝에는 RequireJS를 추가했습니다. <code>script</code> 태그에 <code>data-main="js/main"</code> 이라는 특별한 속성을 추가했는데, 이 속성의 값은 RequireJS가 애플리케이션 전체의 경로 기준점으로 사용합니다.</p>

<p>기본적인 스타일쉬트도 추가해 봅시다.</p>

<pre><code>#container{
    font-family:Calibri, Helvetica, serif;
    color:#444;
    width:200px;
    margin:100px auto 0;
    padding:30px;
    border:1px solid #ddd;
    background:#f6f6f6;
    -webkit-border-radius:4px;
       -moz-border-radius:4px;
            border-radius:4px;
}
 
h1, nav{
    text-align:center;
    margin:0 0 20px;
}
</code></pre>

<h3>OOP 돌아보기. 모듈(module)이란?</h3>

<p>자바스크립트 객체 지향 프로프래밍에는 모듈 패턴(Module Pattern)이라는 정말 많이 사용하는 디자인 패턴이 있습니다. 이 패턴은 글로벌 네임스페이스를 지저분하게 하지 않고 객체 안에 메서드와 속성을 캡슐화하기 위해서 사용합니다.(그래서 <strong>모듈</strong>이라고 합니다.) 그리고 자바나 PHP 같은 다른 OOP 언어의 클래스를 흉내내기 위해서 사용하기도 합니다. 다음은 <code>main.js</code> 파일에 정의한 <code>MyMath</code>라는 간단한 모듈입니다.</p>

<pre><code>var MyMath = (function(){
 
    // Put your private variables and functions here
 
    return { // Here are the public methods
        add:function(a, b){
            return a + b;
        }
    };
})();
 
console.log(MyMath.add(1, 2));
</code></pre>

<p>공개 메서드를 리터럴 객체 형태로 정의했지만 불편합니다. 대신에 리빌링 모듈 패턴(Revealing Module Pattern)을 사용해서 비공개 속성과 메서드를 반환 합니다.</p>

<pre><code>var MyMath = (function(){
 
    // With this pattern you can use the usual function notation:
 
    function add(a, b){
        return a + b;
    }
 
    return {
        add:add // But don't forget to declare it in the returned object!
    };
})();
 
console.log(MyMath.add(1, 2));
</code></pre>

<p>이 튜토리얼에서는 리빌링 모듈 패턴을 사용할 겁니다.</p>

<h2>RequireJS</h2>

<h3>RequireJS로 모듈 정의하기</h3>

<p>앞 절에서 우리는 변수 MyMath에 호출할 모듈을 정의했습니다. 모듈을 꼭 이렇게 정의해야 하는건 아닙니다. 이번에는 RequireJS를 사용해 보겠습니다. RequireJS는 유지보수가 용의하도록 자바스크립트 파일을 쪼개는 역할을 합니다. 그래서 <code>main.js</code>와 같은 폴더에 <code>MyMath</code> 모듈을 정의할 <code>MyMath.js</code> 파일을 생성하겠습니다.</p>

<pre><code>define(function(){
 
    function add(a, b){
        return a + b;
    }
 
    return {
        add:add
    };
});
</code></pre>

<p>MyMath 변수는 사라졌고 <code>define</code> 함수의 파라미터로 모듈을 집어넣었습니다. <code>define</code>함수는 RequireJS가 제공하는 함수로 인데, 외부에서 모듈에 접근할 수 있도록 합니다.</p>

<h3>main 파일에서 모듈 호출하기</h3>

<p>그럼 다시 <code>main.js</code>파일로 돌아가겠습니다. RequireJS는 우리가 만든 <code>MyMath</code> 모듈을 호출하는데 사용할 <code>require</code>라는 함수도 제공합니다. <code>main.js</code>는 이렇게 바뀝니다.</p>

<pre><code>require(['MyMath'], function(MyMath){
 
    console.log(MyMath.add(1, 2)); 
 
});
</code></pre>

<p><code>MyMath</code>를 호출하는 부분은 다음 두 파라미터를 가진 <code>require</code> 함수안에 있습니다.</p>

<ul>
<li>첫 파라미터는 로딩할 모듈의 배열입니다.  모듈의 경로는 경로 기준점(HTML파일의 data-main 속성이 생각나나요?) 기준으로 정의됩니다.  <code>.js</code> 확장자는 생략합니다.</li>
<li>두번째 파라미터는 모듈이 로드될 때 호출할 함수입니다. 모듈은 이 함수의 파라미터로 전달됩니다. 그래서 그냥 모듈명을 파라미터 명으로 하면 됩니다.</li>
</ul>


<p>자. 그럼 이제 페이지를 리로드 해봅시다&hellip; 와우! 축하해요! 여러분은 다른 파일의 모듈을 호출했어요! 그렇습니다. 이건 정말 쉽습니다. 그러면 이제 여러분은 그 무섭다는 MVC 아키텍처를 할 준비가 된겁니다. MVC는 여러분이 정의한 모듈과 정말 비슷하게 동작합니다. 그러므로 당연히 할 수 있습니다.</p>

<h2>MVC 패턴의 구조</h2>

<blockquote><p><strong>잠깐</strong>! : 이 튜토리얼에서는 서버 사이드 MVC처럼 컨트롤러 하나에 뷰 하나를 연결합니다. 하지만 프런트 앤드 개발에서는 한 컨트롤러에 여러 뷰를 연결하는건 정말 일반적이며 이런 경우 뷰는 버튼이나 입력필드 같은 시각적인 컨포넌트가 됩니다. Backbone 같은 자바스크립트 MVC 프레임워크가 이같은 다른 접근을 사용합니다만 그건 이 글이 목적하는 바와는 다릅니다. 여기서 제 목표는 실제 사용하는 MVC 프레임워크 전부를 만들자는게 아니라 여러분이 이미 잘 알고 있는 구조들을 통해서 RequireJS가 어떻게 동작하는지를 그려보자는 겁니다.</p></blockquote>

<p>일단 간단하게 우리 프로젝트의 파일과 폴더부터 생성합시다. 데이터를 표현하는 모델을 사용하려 합니다. 비즈니스 로직은 컨트롤러에서 다루고 그 컨트롤러는 페이지를 렌더링할 특정 뷰를 호출할 겁니다. 그럼 어떻게 될까요? 폴더는 Models, Controllers, Views가 필요하고 두 개의 컨트롤러와 두 개의 뷰, 하나의 모델이 필요합니다.</p>

<p>자바스크립트 폴더구조는 다음과 같습니다.</p>

<pre><code>* Controllers
    * AddController.js
    * ListController.js
* Models
    * User.js
* Views
    * AddView.js
    * ListView.js
* main.js
* require.js
</code></pre>

<p>전체 구조가 준비되었나요? 좋습니다! 가장 간단한 모델 부터 구현합시다.</p>

<h2>모델: User.js</h2>

<p>이 예제에서  <code>User</code>는 <code>name</code> 속성 하나를 가진 간단한 클래스입니다.</p>

<pre><code>define(function(){
 
    function User(name){
        this.name = name || 'Default name';
    }
 
    return User;
});
</code></pre>

<p><code>main.js</code> 파일로 돌아와서, <code>require</code>  메서드로 <code>User</code>를 사용하게 정의할 수 있습니다. 그리고 예제 목적에 부합하게 사용자 목록을 생성해 보겠습니다.</p>

<pre><code>require(['Models/User'], function(User){
 
    var users = [new User('Barney'),
                 new User('Cartman'),
                 new User('Sheldon')];
 
    for (var i = 0, len = users.length; i &lt; len; i++){
        console.log(users[i].name);
    }
 
    localStorage.users = JSON.stringify(users);
});
</code></pre>

<p>사용자 배열을 JOSN에서 시리얼라이즈 한 후에 데이터베이스처럼 접근하기 위해서 HTML5 로컬 스토리지에 저장합니다.</p>

<p><img src="http://farm8.staticflickr.com/7238/7164952261_79b56e2412.jpg" alt="" /></p>

<blockquote><p><strong>잠깐</strong> : JSON을 시리얼라이즈하는 stringify와 디시리얼라이즈하는 parse를 IE7에서 사용하려면 폴리필(polyfill)이 필요합니다. 더글라스 클락포트씨의 <a href="https://github.com/douglascrockford/JSON-js">Github 레파지토리</a>에 보면<code>json2.js</code>라고 있습니다.</p></blockquote>

<h2>사용자 목록 출력</h2>

<p>이제 이렇게 저장한 사용자를 출력할 차례입니다. 이 일을 할 <code>ListController.js</code>와 <code>ListView.js</code>를 만들겠습니다. 두 컴포넌트는 관련이 있습니다. 그래서 어떤 식으로든 연결이 되야 합니다. 많은 방법이 있습니다만 예제를 단순하게 하기 위해서 여기선 이렇게 하겠습니다. <code>ListView</code>는 <code>render</code>란 메서드를 갖고, <code>ListController</code>는 로컬 스토리지에서 가져온 사용자를 파라미터로 해서 <code>ListView의 render</code> 메서드를 호출합니다.  그렇습니다. <code>ListController</code>는 <code>ListView</code>에 의존합니다.</p>

<p>RequireJS에서는 <code>require</code> 메서드처럼 <code>define</code> 메서드에서도 의존성 있는 관련 모듈을 배열로 넘길 수 있습니다. 모듈안에서 해당 컨트롤러의 메인 동작으로 놓을 <code>start</code> 메서드를 만듭시다. (뭐, <code>run</code>이나 <code>main</code>같은 이름도 좋습니다.) <code>ListController.js</code> 를 봅시다.</p>

<pre><code>define(['Views/ListView'], function(ListView){
 
    function start(){
        var users = JSON.parse(localStorage.users);
        ListView.render({users:users});
    }
 
    return {
        start:start
    };
});
</code></pre>

<p>여기서는 로컬스토리지의 users를  디시리얼라이징 합니다. 그리고 <code>render</code>메서드에 객체로 넘깁니다. 이제 <code>ListView.js</code>의 <code>render</code> 메서드만 구현하면 끝이군요.</p>

<pre><code>define(function(){
 
    function render(parameters){
        var appDiv = document.getElementById('app');
 
        var users = parameters.users;
 
        var html = '&lt;ul&gt;';
        for (var i = 0, len = users.length; i &lt; len; i++){
            html += '&lt;li&gt;' + users[i].name + '&lt;/li&gt;';
        }
        html += '&lt;/ul&gt;';
 
        appDiv.innerHTML = html;
    }
 
    return {
        render:render
    };
});
</code></pre>

<p><code>render</code> 메서드는 <code>#app</code> 문서요소에 집어넣을 HTML 문자열을 만들기 위해서 users를 순회작업 하는게 전부입니다.</p>

<blockquote><p><strong>잠깐</strong> : 이런 식으로 자바스크립트 파일에서 HTML을 사용하는건 좋은 생각이 아닙니다. 나중에 수정할 때 너무 힘들거든요. 템플릿 사용을 고려해야 합니다. 템플릿은 HTML 마크업에 데이터를 넣는 훌륭한 방법입니다. 좋은 템플릿 시스템이 정말 많이 있습니다. 예를 들면 <a href="https://github.com/jquery/jquery-tmpl">jQuery-tmpl</a>이나 <a href="https://github.com/janl/mustache.js">Mustache.js</a> 가 있습니다. 하지만 이 글의 범위를 벗어나는 주제이고 지금의 구조를 복잡하게 만들겁니다. 여기선 단순하게 갑시다.</p></blockquote>

<p>이제 <code>ListController</code> 모듈을 <strong>실행</strong>할 차례입니다. <code>main.js</code> 파일에서 <code>require</code> 메서드로 <code>ListController</code>를 선언하고 <code>ListController.start()</code>를 호출합시다.</p>

<pre><code>require(['Models/User', 'Controllers/ListController'], function(User, ListController){
 
    var users = [new User('Barney'),
                 new User('Cartman'),
                 new User('Sheldon')];
 
    localStorage.users = JSON.stringify(users);
 
    ListController.start();
});
</code></pre>

<p>페이지를 리로드 하면 멋진 사용자 목록을 볼 수 있습니다.</p>

<p><img src="http://farm8.staticflickr.com/7094/7350164284_74cb98faa9.jpg" alt="" /></p>

<p>와~~! 이겁니다! 여러분도 같이 코딩했다면 축하합니다!</p>

<blockquote><p><strong>잠깐</strong> : 지금은 라우팅 시스템이 없기때문에 실행하고 싶은 컨트롤러는 수동으로만 정의할 수 있습니다. 하지만 곧 정말 간단히 생성할 수 있게 됩니다. 기다리세요. ㅋ</p></blockquote>

<h2>사용자 등록하기</h2>

<p>이제 목록에 사용자를 등록할수 있으면 좋겠군요. 간단한 텍스트 입력 필드와 버튼를 보여주고 버튼을 클릭하면 로컬 스토리지에 사용자를 추가하는 이벤트 핸들러를 등록할 예정입니다. 앞에서 했던 작업과 비슷한 <code>AddController</code>에서 시작합시다. 이 파일은 뷰로 파라미터를 전혀 넘기지 않기때문에 무척 간단합니다.  <code>AddContoller.js</code>를 보시죠.</p>

<pre><code>define(['Views/AddView'], function(AddView){
 
    function start(){
        AddView.render();
    }
 
    return {
        start:start
    };
});
</code></pre>

<p>이어서 뷰 파일 <code>AddView.js</code>입니다.</p>

<pre><code>define(function(){
 
    function render(parameters){
        var appDiv = document.getElementById('app');
        appDiv.innerHTML = '&lt;input id="user-name" /&gt;&lt;button id="add"&gt;Add this user&lt;/button&gt;';
    }
 
    return {
        render:render
    };
});
</code></pre>

<p>이제 여러분의 <code>main.js</code>파일에서 <code>AddController</code>를 정의해서 다음 뷰를 무사히 가져올 <code>start</code> 메서드를 호출할 수 있습니다.</p>

<p><img src="http://farm8.staticflickr.com/7218/7164952349_2179e0f982.jpg" alt="" /></p>

<p>하지만 아직 버튼에 이벤트 연결을 하지 않았으므로 지금의 뷰는 별 의미는 없습니다. 이제 그 작업을 하기전에 한가지 질문을 해봅니다. 클릭 이벤트에 대한 이벤트 로직은 어디에 놓아야 할까요? 뷰일까요? 컨트롤러일까요? 이벤트 리스너 위치가 뷰라고 생각하고 이벤트 비즈니스 로직을 놓는건 상당히 안 좋은 습관입니다. 비록 컨트롤러에 뷰에 있는 div의 ID가 없는게 더 좋으니까 완벽하다 할 수는 없지만 컨트롤러에 이벤트 로직를 놓는게 더 좋습니다.</p>

<blockquote><p><strong>잠깐</strong> : 가장 좋은 방법은 뷰에는 이벤트 리스너 함수가 있고, 그 함수가 컨트롤러나 이벤트 처리 전용 모듈에 있는 비즈니스 로직 메서드를 호출하는 겁니다. 이 방식이 어려운건 아니지만 이 때문에 예제가 복잡해져서 여러분이 포기할길 원치는 않습니다. 연습할 때 시도해도 됩니다.</p></blockquote>

<p>말한 것 처럼, 이벤트 로직을 컨트롤러에 짜봅시다. <code>AddController</code>에 <code>bindEvents</code> 함수를 만듭니다. 그리고 뷰가 HTML 렌더링을 끝내면 이 함수를 호출합니다.</p>

<pre><code>define(['Views/AddView', 'Models/User'], function(AddView, User){
 
    function start(){
        AddView.render();
        bindEvents();
    }
 
    function bindEvents(){
        document.getElementById('add').addEventListener('click', function(){
            var users = JSON.parse(localStorage.users);
            var userName = document.getElementById('user-name').value;
            users.push(new User(userName));
            localStorage.users = JSON.stringify(users);
            require(['Controllers/ListController'], function(ListController){
                ListController.start();
            });
        }, false);
    }
 
    return {
        start:start
    };
});
</code></pre>

<p><code>bindEvents</code>에서는 <code>#add</code> 버튼의 클릭 이벤트에 이벤트 리스너를 추가합니다. (IE의 <code>attachEvent</code>를 위해서 만들어둔 함수가 있다면 그걸 써도 되고 jQuery를 써도 됩니다. ) 버튼을 클릭하면, 로컬 스토리지에서 사용자를 users 변수에 문자열을 가져와서 배열로 디시리얼라이즈하고 <code>#user-name</code> 입력 필드에 있는 이름으로 새로운 user를 넣습니다. 그리고 갱신된 users 배열을 로컬 스토리지에 다시 저장합니다. <code>require</code>로 <code>ListController</code>를 가져와서 <code>start</code> 메서드를 실행합니다. 그러면 다음 화면을 볼 수 있습니다.</p>

<p><img src="http://farm8.staticflickr.com/7218/7164952397_3190c81f3a.jpg" alt="" /></p>

<p>멋지군요! 여기까지 예제를 같이 짰다면 이제 잠시 쉬어도 됩니다. 커피 한잔 타오고 계속하죠.</p>

<h2>라우터로 뷰 화면간 이동하기</h2>

<p>자 다시 합시다. 우리가 만든 앱은 상당히 멋져보이긴 하지만 실제로는 사용자를 한 명 더 추가하기 위해서  등록 뷰로 이동할 수 없으므로 영 별로입니다. 라우팅(<em>routing</em>) 시스템을 빼먹었습니다. 서버 사이드 MVC 프레임워크로 작업해본 적이 있다면 아마도 라우팅이 익숙할 겁니다. URL은 각자 다른 뷰를 불러옵니다. 하지만 우리는 클라이언트 사이드 작업을 하고 있고 서버 사이드와는 확실히 다릅니다. 이와 같은 자바스크립트 단일 페이지 인터페이스에서 해당 앱의 다른 부분으로 이동하려면 URL 해시(hash)를 사용합니다. 우리 경우에는 다음 URL을 입력할 때 두 개의 다른 뷰를 찾을 수 있어야 합니다.</p>

<ul>
<li><a href="http://yourlocalhostpath/#list">http://yourlocalhostpath/#list</a></li>
<li><a href="http://yourlocalhostpath/#add">http://yourlocalhostpath/#add</a></li>
</ul>


<p>이렇게해서 각 페이지를 쉽게 접근할 수 있고 북마크도 가능해 집니다.</p>

<blockquote><p><strong>잠깐</strong> : 파이어폭스, 크롬, 오페라는 HTML5 히스토리 관리(pushState, popState, replaceState) 지원 기능이 있어서 해시를 다루지 않아도 됩니다.</p></blockquote>

<h3>브라우저 호환성과 응용</h3>

<p>구형 브라우저를 지원해야 한다면 히스토리와 해시 이동 관리가 쉽지 않습니다. 지원하기로 정한 브라우저와 관련해서 여러분이 결정할 수 있는 몇가지 해법이 여기 있습니다.</p>

<ul>
<li><a href="http://caniuse.com/#search=history">가장 앞선 브라우저</a> : HTML5 history management.</li>
<li><a href="http://caniuse.com/#search=hashchange">대부분의 최신 브라우저</a> : HTML5 hashchange event.</li>
<li>구형 브라우저 : hash 변경 감시를 수동으로 해야 합니다.</li>
<li>정말 오래된 브라우저 : 수동 감시 + iframe 핵</li>
</ul>


<p>이중에 구현이 간단한 수동 감시를 구현할 겁니다. n 밀리초 마다 hash가 변경되었는 지를 확인하는게 전부입니다. 변경이 확인되면 필요한 함수를 호출합니다.</p>

<blockquote><p><strong>잠깐</strong> : 이 작업을 해주는 <a href="https://github.com/cowboy/jquery-hashchange">jQuery 플러그인</a>도 있습니다.</p></blockquote>

<h3>라우터와 메인 라우터 순회</h3>

<p><code>main.js</code> 다음에는 라우팅 로직을 관리할 <code>Router.js</code> 파일을 만듭시다. <code>Router.js</code>에서는 경로를 정의하고 URL에 정의된게 없을 때 사용할 기본값을 정의해야 합니다. 우리는 인스턴스에 <strong>해시(hash)</strong>와 관련 <strong>컨트롤러(controller)</strong>를 가진 객체의 단순 배열을 사용할 수 있습니다. URL에 해시가 없을 때 사용할 <strong>기본값(defaultRoute)</strong>도 필요합니다.</p>

<pre><code>define(function(){
 
    var routes = [{hash:'#list', controller:'ListController'},
                  {hash:'#add',  controller:'AddController'}];
    var defaultRoute = '#list';
    var currentHash = '';
 
    function startRouting(){
        window.location.hash = window.location.hash || defaultRoute;
        setInterval(hashCheck, 100);
    }
 
    return {
        startRouting:startRouting
    };
});
</code></pre>

<p><code>startRouting</code>이 호출되면, URL에 기본 해시 값을 지정합니다. 그리고 <code>hashCheck</code>를 반복해서 호출하기 시작합니다. <code>hashCheck</code>는 아직 구현하지 않은 함수입니다. <code>currentHash</code> 변수는 해시 변경이 감지되면 해시의 현재 값을 저장할 때 사용합니다.</p>

<h3>해시 변화 확인</h3>

<p>이 함수가 <code>hashCheck</code>입니다. 100 밀리초마다 호출됩니다.</p>

<pre><code>function hashCheck(){
    if (window.location.hash != currentHash){
        for (var i = 0, currentRoute; currentRoute = routes[i++];){
            if (window.location.hash == currentRoute.hash)
                loadController(currentRoute.controller);
        }
        currentHash = window.location.hash;
    }
}
</code></pre>

<p><code>hashCheck</code>는 <code>currentHash</code>와 값 비교를 해서 해시가 변경됬는지 확인합니다. 그리고 라우터중 하나와 일치하면 관련 컨트롤러 명으로 <code>loadController</code>를 호출합니다.</p>

<h3>적절한 컨트롤러 로딩</h3>

<p>이제, <code>loadController</code>는 컨트롤러의 모듈을 로드할 <code>require</code> 를 호출해서 해당 모듈의 <code>start</code> 함수를 실행합니다.</p>

<pre><code>function loadController(controllerName){
    require(['Controllers/' + controllerName], function(controller){
        controller.start();
    });
}
</code></pre>

<p><code>Router.js</code>는 결국 이렇게 완성됩니다.</p>

<pre><code>define(function(){
 
    var routes = [{hash:'#list', controller:'ListController'},
                  {hash:'#add',  controller:'AddController'}];
    var defaultRoute = '#list';
    var currentHash = '';
 
    function startRouting(){
        window.location.hash = window.location.hash || defaultRoute;
        setInterval(hashCheck, 100);
    }
 
    function hashCheck(){
        if (window.location.hash != currentHash){
            for (var i = 0, currentRoute; currentRoute = routes[i++];){
                if (window.location.hash == currentRoute.hash)
                    loadController(currentRoute.controller);
            }
            currentHash = window.location.hash;
        }
    }
 
    function loadController(controllerName){
        require(['Controllers/' + controllerName], function(controller){
            controller.start();
        });
    }
 
    return {
        startRouting:startRouting
    };
});
</code></pre>

<h3>새로 만든 라우팅 시스템 적용하기</h3>

<p>이제 남은 일은 <code>main.js</code> 파일에서 라우터 모듈을 <code>require</code>로 요청해서 <code>startRouting</code> 함수를 호출하는 일 뿐입니다.</p>

<pre><code>require(['Models/User', 'Router'], function(User, Router){
 
    var users = [new User('Barney'),
                 new User('Cartman'),
                 new User('Sheldon')];
 
    localStorage.users = JSON.stringify(users);
 
    Router.startRouting();
});
</code></pre>

<p>우리가 만드는 앱의 한 컨트롤러에서 다른 곳으로 이동하려면, 새 컨트롤러의 해시 경로로  현재 <code>window.hash</code>를 교체하면 됩니다. 이런 경우 새로운 라우팅 시스템 대신에 아직 수동으로 <code>AddController</code>의 <code>ListController</code>를 로딩하고 있습니다.</p>

<pre><code>require(['Controllers/ListController'], function(ListController){
    ListController.start();
});
</code></pre>

<p>이 3줄을 해시 업데이트로 바꿔 버립시다.</p>

<pre><code>window.location.hash = '#list';
</code></pre>

<p>자! 이겁니다. 우리 앱은 이제 응용 가능한 라우팅 시스템을 갖췄습니다. 한 뷰에서 다른 뷰로 이동할 수 있고, 반대로  URL에 원하는 해시를 넣을 수 있습니다. 그러면 정의된 라우터에 일치하는 해시를 찾아서 적절한 컨트롤러를 로딩합니다. 멋지죠?</p>

<p><a href="http://verekia.com/demo/require-js/">동작하는 데모</a>는 여기서 보세요.</p>

<h2>결론</h2>

<p>여러분은 프레임워크 없이 완전한 MVC 앱을 만들었으므로 자부심을 가져도 됩니다. 모듈 생성에 필요한 필수 요소만 있는 파일들을 연결하기 위해서 RequireJS를 사용했을 뿐이죠. 그럼 다음은 뭘 해야 할까요? 이 튜토리얼을 보고 여러분이 직접한 이 작은 작업이 맘에 든다면 앱에 기능을 추가해서 우리가 만든 작은 프레임워크를 확장할 수 있습니다. 그러려면 필요한 새로운 기법들이 있습니다. 시도해볼 만한 다음 단계에 대해 몇가지 아이디어가 있습니다.</p>

<ul>
<li>템플릿 시스템을 통합합니다.</li>
<li>라우팅 시스템처럼 앱과 직접 관련 없으면서 다른 프로젝트에서 재사용 가능한 부분을 분리해서 작은 확장 라이브러리를 생성합니다.</li>
<li>그 라이브러리에서 모델, 뷰, 컨트롤러를 객체로 정의합니다.</li>
<li>다양한 소스의 데이터(RESTfull APS, localStorage, IndexedDB 등)를 다룰 새로운 추상 계층을 생성합니다.</li>
</ul>


<p>이런 DIY 접근은 학습용으로는 훌륭하지만, 현시점에서 실 프로젝트에 적용하기에는 현재 프레임워크 상태가 그리 적합하지는 않습니다. 앞에 나열한 기능을 구현할만큼 부지런하지 않다면, 이미 존재하는 MVC 프레임워크 사용법을 배워 볼 수 있습니다. 가장 인기 있는 MVC 프레임워크입니다.</p>

<ul>
<li><a href="http://documentcloud.github.com/backbone/">Backbon</a></li>
<li><a href="http://javascriptmvc.com/">JavaScriptMVC</a></li>
<li><a href="http://www.sproutcore.com/">Sproutcore</a></li>
<li><a href="http://www.sencha.com/products/extjs/">ExtJS</a></li>
<li><a href="http://knockoutjs.com/">Knockout</a></li>
</ul>


<p>개인적으로는 최소화 버전이 5kb가 안되서 Backbone를 좋아합니다. 그래서 다음 튜토리얼은 RequireJS와 Backbone를 정말 멋지게 엮어서 사용하는 법에 대해 다룰 예정입니다. 이 내용을 알고 싶으면 <a href="http://twitter.com/#!/verekia">@verekia</a>를 팔로우 하세요. 그리고 <strong>애디 오스마니(Addy Osmani)</strong>씨의 <a href="http://addyosmani.com/blog/large-scale-jquery/">대형 jQuery 애플리케이션</a>과 <a href="http://addyosmani.com/writing-modular-js/">자바스크립트 모듈</a>에 대한 튜토리얼을 읽고 그를 팔로우 하고 RequireJS를 만든 <strong>제임스 퍼크(James Burke)</strong>씨도 팔로우하기를 추천합니다. 두 사람 모두 모듈 기반 자바스크립트 앱의 정보통입니다. 애디 오스마니씨는 <a href="http://addyosmani.github.com/todomvc/">TodoMVC</a>라는 프로젝트도 시작했습니다. TodoMVC는  간단한 동일 웹 앱을 각기 다른 MVC 프레임워크를 사용해서 만드는 방법을 비교하는 프로젝트입니다. 여러분이 적절한 프레임워크를 선택하는데 도움이 될 겁니다.</p>

<p>오늘은 여기까집니다. 읽어주셔서 감사합니다.</p>
]]></content>
  </entry>
  
</feed>
