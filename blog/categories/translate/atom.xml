<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Translate | zziuni's Blog]]></title>
  <link href="http://zziuni.github.io/blog/categories/translate/atom.xml" rel="self"/>
  <link href="http://zziuni.github.io/"/>
  <updated>2013-12-01T18:21:37+09:00</updated>
  <id>http://zziuni.github.io/</id>
  <author>
    <name><![CDATA[zziuni]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Grunt: Create tasks in korean]]></title>
    <link href="http://zziuni.github.io/blog/2013/12/01/grunt-create-tasks-in-korean/"/>
    <updated>2013-12-01T12:11:00+09:00</updated>
    <id>http://zziuni.github.io/blog/2013/12/01/grunt-create-tasks-in-korean</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://gruntjs.com">Grunt</a>은 Javascript Task Runner 입니다.. 이 문서는 Grunt 공식 사이트의 <a href="http://gruntjs.com/creating-tasks">Create tasks</a>를 번역한 문서이며 grunt-cli의 버전이 0.1.11일 때 번역했습니다.</p></blockquote>

<h1>Create tasks</h1>

<p>Task는 Grunt의 존재 이유이자 가장 중요한 개념이다. 여러분이 하는 대부분의 일(task)은 <code>jshint</code>나 <code>nodeunit</code>같은 것들이다. 실행할 Task를 하나 이상 명시해서 Grunt에게 하고 싶은 일이 무엇인지 알려주면, Grunt가 그 일을 매번 실행한다.</p>

<p>여러분이 task를 새로 명시하지 않았고, &ldquo;default"란 이름의 task가 이미 정의되어 있다면, 기본값으로 그 task가 실행된다.</p>

<!-- more -->


<h2>Alias Tasks</h2>

<p>다음처럼 새로운 task에 다른 task 명단을 명시하면, 그 신규 task의 이름은 여러 task들을 대표하는 별명(alias)이 된다. 이런 &ldquo;alias task"가 실행될 때면, <code>taskList</code>에 명시한 모든 task들이 순서대로 실행된다. 이때 <code>taskList</code> 전달인자는 배열이다.</p>

<p><code>javascript
grunt.registerTask(taskName, [description, ] taskList)
</code></p>

<p>다음 예제는 Grunt를 특정 task 지정없이 <code>grunt</code>로 실행할 때 자동으로 &ldquo;jshint&rdquo;, &ldquo;qunit&rdquo;, &ldquo;concat&rdquo;, &ldquo;uglify&rdquo; task들을 실행하는 &ldquo;default"라는 alias task다.</p>

<p><code>javascript
grunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']);
</code></p>

<p>Task 전달인자를 다음처럼 지정할 수도 있다. &ldquo;dist"라는 alias task는 "concat"과 "uglify"에서 "dist&rdquo; target 들만 실행한다.</p>

<p><code>javascript
grunt.registerTask('dist', ['concat:dist', 'uglify:dist']);
</code></p>

<h2>Multi Tasks</h2>

<p>Multi-task로 만든 task는 실행될 때, Grunt 환경 설정 객체에서 동명의 프로퍼티를 찾는다. 또한 multi-task는 적절한 target(task의 하위 개념) 명으로 각자의 환경설정을 가질 수 있다.</p>

<p><code>grunt concat</code>란 컴멘드가 그 안의 모든 target를 순회하는 반면에, <code>grunt concat:foo</code>나 <code>grunt concat:bar</code>처럼 task와 target까지 지정하면, 특정 target의 환경설정만 가져온다. 이때  <a href="http://gruntjs.com/grunt.task#grunt.task.renametask">grunt.task.renameTask</a>로 이름을 변경하면, 바꾼 task 명으로 환경 설정을 찾는다.</p>

<p><a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint plugin jshint task</a>와 <a href="https://github.com/gruntjs/grunt-contrib-concat">grunt-contrib-concat plugin concat task</a>같이 contrib로 시작하는 대부분의 task는 multi task다.</p>

<p><code>javascript
grunt.registerMultiTask(taskName, [description, ] taskFunction)
</code></p>

<p>다음 multi-task에서 <code>grunt log:foo</code>로 grunt를 실행하면 <code>foo: 1,2,3</code>가 로그로 찍히고, <code>grunt log:bar</code>로 grunt를 실행하면 <code>bar: hello world</code>가 찍힌다. 하지만 <code>grunt log</code>로 grunt를 실행하면 순서대로 <code>foo: 1,2,3</code>가 찍히고 <code>bar: hello world</code>가 찍힌 다음 <code>baz: false</code>가 찍힌다.</p>

<p>```javascript
grunt.initConfig({
  log: {</p>

<pre><code>foo: [1, 2, 3],
bar: 'hello world',
baz: false
</code></pre>

<p>  }
});</p>

<p>grunt.registerMultiTask(&lsquo;log&rsquo;, &lsquo;Log stuff.&rsquo;, function() {
  grunt.log.writeln(this.target + &lsquo;: &rsquo; + this.data);
});
```</p>

<h2>&ldquo;Basic&rdquo; Tasks</h2>

<p>Multi-task가 아닌 기본 task가 실행될 때는 Grunt가 환경설정을 바라보지 않는다. 지정한 task function만 실행한다. 기본 task에서는 콜론(:)로 구분한 인자 목록을 task function 함수의 전달인자로 넘길 수 있다.</p>

<p><code>javascript
grunt.registerTask(taskName, [description, ] taskFunction)
</code></p>

<p><code>grunt foo:testing:123</code>를 입력하면 <code>foo, testing 123</code>가 콘솔에 출력된다. <code>grunt foo</code>처럼 아무 인자도 넘기지 않고 실행하면 <code>foo, no args</code>가 콘솔에 찍힌다.</p>

<p>```javascript
grunt.registerTask(&lsquo;foo&rsquo;, &lsquo;A sample task that logs stuff.&rsquo;, function(arg1, arg2) {
  if (arguments.length === 0) {</p>

<pre><code>grunt.log.writeln(this.name + ", no args");
</code></pre>

<p>  } else {</p>

<pre><code>grunt.log.writeln(this.name + ", " + arg1 + " " + arg2);
</code></pre>

<p>  }
});
```</p>

<h2>Custom tasks</h2>

<p>만들려는 Task가 &ldquo;multi-task&rdquo; 구조를 따르지 않는다면 기본 task형태로 사용자 정의  task를 만들자.</p>

<p><code>javascript
grunt.registerTask('default', 'My "default" task description.', function() {
  grunt.log.writeln('Currently running the "default" task.');
});
</code></p>

<p>task 안에서 다른 task를 실행할 수 있으며,</p>

<p><code>javascript
grunt.registerTask('foo', 'My "foo" task.', function() {
  // "bar"와 "baz" task가 "foo" 가 끝난 후에 순서대로 실행하려고 대기중이다.
  grunt.task.run('bar', 'baz');
  // 이렇게 적어도 된다.
  grunt.task.run(['bar', 'baz']);
});
</code></p>

<p>비동기도 가능하다.</p>

<p>```javascript
grunt.registerTask(&lsquo;asyncfoo&rsquo;, &lsquo;My &ldquo;asyncfoo&rdquo; task.&rsquo;, function() {
  // task를 비동기 모드로 만들고 &ldquo;done&rdquo; 함수로 제어한다.
  var done = this.async();
  // 동기 작업을 실행한다.
  grunt.log.writeln(&lsquo;Processing task&hellip;&rsquo;);
  // 그리고 비동기 작업을 실행한다.
  setTimeout(function() {</p>

<pre><code>grunt.log.writeln('All done!');
done();
</code></pre>

<p>  }, 1000);
});
```</p>

<p>이렇게 만든 task도 그 이름과 인자를 사용해서 접근할 수 있다.</p>

<p>```javascript
grunt.registerTask(&lsquo;foo&rsquo;, &lsquo;My &ldquo;foo&rdquo; task.&rsquo;, function(a, b) {
  grunt.log.writeln(this.name, a, b);
});</p>

<p>// 사용법:
// grunt foo foo:bar
//   출력로그: &ldquo;foo&rdquo;, undefined, undefined
//   출력로그: &ldquo;foo&rdquo;, &ldquo;bar&rdquo;, undefined
// grunt foo:bar:baz
//   출력로그: &ldquo;foo&rdquo;, &ldquo;bar&rdquo;, &ldquo;baz&rdquo;
```</p>

<p>Task에서 에러가 발생하면 Task를 실패처리 할 수도 있다.</p>

<p>```javascript
grunt.registerTask(&lsquo;foo&rsquo;, &lsquo;My &ldquo;foo&rdquo; task.&rsquo;, function() {
  if (failureOfSomeKind) {</p>

<pre><code>grunt.log.error('에러 메세지');
</code></pre>

<p>  }</p>

<p>  // task 실행 중 에러가 있다면 false를 반환해서 실패 처리한다.
  if (ifErrors) { return false; }</p>

<p>  grunt.log.writeln(&lsquo;성공 메세지&rsquo;);
});
```</p>

<p>task가 실패하면, <code>--force</code>를 붙이지 않는한 그 이후 작업은 모두 중단된다.</p>

<p>```javascript
grunt.registerTask(&lsquo;foo&rsquo;, &lsquo;My &ldquo;foo&rdquo; task.&rsquo;, function() {
  // 동기적 실패 처리
  return false;
});</p>

<p>grunt.registerTask(&lsquo;bar&rsquo;, &lsquo;My &ldquo;bar&rdquo; task.&rsquo;, function() {
  var done = this.async();
  setTimeout(function() {</p>

<pre><code>// 비동기적 실패 처리
done(false);
</code></pre>

<p>  }, 1000);
});
```</p>

<p>Task는 다른 task가 성공적으로 실행되었는지 여부와 관련지을 수도 있다. <code>grunt.task.requires</code>는 실제로 다른 task를 실행하지는 않지만, 그 task가 실행되었는지, 실패는 없었는지를 확인한다.</p>

<p>```javascript
grunt.registerTask(&lsquo;foo&rsquo;, &lsquo;My &ldquo;foo&rdquo; task.&rsquo;, function() {
  return false;
});</p>

<p>grunt.registerTask(&lsquo;bar&rsquo;, &lsquo;My &ldquo;bar&rdquo; task.&rsquo;, function() {
  // &ldquo;foo&rdquo; task가 실패했거나 실행된적이 없다면, 이 task를 실패 처리한다.
  grunt.task.requires(&lsquo;foo&rsquo;);
  // 이 코드는 &ldquo;foo&rdquo; task가 성공적으로 실행된 적이 있을 때만 실행된다.
  grunt.log.writeln(&lsquo;Hello, world.&rsquo;);
});</p>

<p>// 사용법
// grunt foo bar
//   foo가 실패하는 task이므로 로그는 출력되지 않는다.
// grunt bar
//   foo가 실행된적이 없으므로 로그는 출력되지 않는다.
```</p>

<p><code>grunt.config.requires</code>를 사용하면, Task가 존재하지 않는 환경설정 프로퍼티를 요구할 때, 실패 처리할 수 있다.</p>

<p><code>javascript
grunt.registerTask('foo', 'My "foo" task.', function() {
  // "meta.name" 란 환경설정 프로퍼티가 없으면 이 타스트를 실패 처리한다.
  grunt.config.requires('meta.name');
  // 이경우도 "meta.name" 환경설정 프로퍼티가 없다면, 실패한다.
  grunt.config.requires(['meta', 'name']);
  // 조건이 충족되어야 로그가 출력된다.
  grunt.log.writeln('meta.name이 환경설정에 정의되어있을 때만 로그가 출력된다.');
});
</code></p>

<p>환경설정 프로퍼티에는 <code>grunt.config</code>로 접근할 수 있다.</p>

<p><code>javascript
grunt.registerTask('foo', 'My "foo" task.', function() {
  // 프로퍼티 값을 로그로 출력한다. 프로퍼티가 undefined이면 null을 반환한다.
  grunt.log.writeln('The meta.name property is: ' + grunt.config('meta.name'));
  // 이경우도 프로퍼티 값을 로그로 출력한다. 프로퍼티가 undefined이면 null을 반환한다.
  grunt.log.writeln('The meta.name property is: ' + grunt.config(['meta', 'name']));
});
</code></p>

<p>더 자세한 예제는 <a href="https://github.com/gruntjs/">contrib task</a>들을 참고하자.</p>

<h2>CLI optiosn / environment</h2>

<p>내용 없음.</p>

<h2>Why doesn&rsquo;t my asynchronous task complete?</h2>

<p>비동기 task를 짰는데 완료되지 않는다면, 대부분 <a href="http://gruntjs.com/grunt.task#wiki-this-async">this.asynce</a>를 호출하지 않았기 때문이다. 쉽게 하려면, 동기식 코딩 스타일을 사용하고 나서 task 내부에 <code>this.async()</code>를 호출해서 비동기로 변경할 수 있다.</p>

<p>그리고 다시 말하지만, <code>done()</code>에 인자로 <code>false</code>를 넘기면 Grunt에게 task가 실패했다고 알릴 수 있다.</p>

<p>예제 코드다.</p>

<p><code>javascript
grunt.registerTask('asyncme', 'My asynchronous task.', function() {
  var done = this.async();
  doSomethingAsync(done);
});
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt: Sample Gruntfile in korean]]></title>
    <link href="http://zziuni.github.io/blog/2013/11/26/grunt-sample-gruntfile-in-korean/"/>
    <updated>2013-11-26T00:31:00+09:00</updated>
    <id>http://zziuni.github.io/blog/2013/11/26/grunt-sample-gruntfile-in-korean</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://gruntjs.com">Grunt</a>은 Javascript Task Runner 입니다.. 이 문서는 Grunt 공식 사이트의 <a href="http://gruntjs.com/sample-gruntfile">Sample Gruntfile</a>를 번역한 문서이며 grunt-cli의 버전이 0.1.11일 때 번역했습니다.</p></blockquote>

<h1>Sample Gruntfile</h1>

<p>다음 다섯 개의 Grunt 플러그인을 사용하는 <code>Gruntfile</code> 샘플을 살펴보겠다.</p>

<ul>
<li><a href="https://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-qunit">grunt-contrib-qunit</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-concat">grunt-contrib-concat</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-watch">grunt-contrib-watch</a></li>
</ul>


<!-- more -->


<p>전체 <code>Gruntfile</code>은 이 페이지 가장 아래에 제공하지만, 순서대로 읽어야 단계별로 이해할 수 있다.</p>

<p>첫 부분은 Grunt 환경설정을 캡슐화하는 &ldquo;wrapper&rdquo; 함수다.</p>

<p><code>javascript
module.exports = function(grunt){
}
</code></p>

<p>이 함수안에서 환경설정 객체를 생성할 수 있다.</p>

<p><code>javascript
grunt.initConfig({
});
</code></p>

<p>다음은 <code>pkg</code>프로퍼티에 <code>package.json</code>파일의 프로젝트 설정을 읽어서 설정한다. 이를 통해서 <code>package.json</code> 파일의 프로퍼티 값들을 참조할 수 있다. 조금만 더 읽으면 볼 수 있다.</p>

<p><code>javascript
pkg: grunt.file.readJSON("package.json");
</code></p>

<p>여기까지 본 것을 합치면 이렇게 된다.</p>

<p>```javascript
module.exports = function(grunt) {
  grunt.initConfig({</p>

<pre><code>pkg: grunt.file.readJSON('package.json')
</code></pre>

<p>  });
};
```</p>

<p>이제, task 별 환경설정을 정의할 수 있다. task를 위한 환경설정 객체는 전체 환경설정 객체에서 task 명과 동일한 이름의 프로퍼티로 존재한다. 즉, &ldquo;concat&rdquo; task는 환경설정 객체의 &ldquo;concat&rdquo; 프로퍼티에 있다. 다음은 &ldquo;concat"을 위한 task 환경설정 객체의 예제다.</p>

<p>```javascript
concat: {
  options: {</p>

<pre><code>// 합친 결과 파일에서 각 파일을 구분할 문자열을 정의한다. 
separator: ';'
</code></pre>

<p>  },
  dist: {</p>

<pre><code>// 합칠 파일들.
src: ['src/**/*.js'],
// 결과 js 파일의 위치
dest: 'dist/&lt;%= pkg.name %&gt;.js'
</code></pre>

<p>  }
}
```</p>

<p><code>package.json</code>의 <code>name</code> 프로퍼티를 어떻게 참조했는지 보이는가? 우리는 <code>package.json</code>을 불러온 결과가 들어있는 <code>pkg</code> 프로퍼티를 통해서 <code>pkg.name</code>로 접근했다. 이 값은 이미 자바스크립트 객체로 파싱되어있다. Grunt는 환경설정 객체의 프로퍼티 값을 뱉어내는 탬플릿 엔진을 가지고 있다. 여기서는 <code>src/</code> 폴더에서 확장자가 <code>.js</code>인 파일 전부를 합치는 concat task를 설정했다.</p>

<p>이번에는 자바스크립트를 minify(공백을 제거하고 변수명을 짧은 이름으로 바꾸는 작업)하는 uglify 플러그인을 설정해보자.</p>

<p>```javascript
uglify: {
  options: {</p>

<pre><code>// 결과 파일 상단에 주석을 넣는다. 
banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("dd-mm-yyyy") %&gt; */\n'
</code></pre>

<p>  },
  dist: {</p>

<pre><code>files: {
  'dist/&lt;%= pkg.name %&gt;.min.js': ['&lt;%= concat.dist.dest %&gt;']
}
</code></pre>

<p>  }
}
```</p>

<p>이제 uglify task는 minify한 자바스크립트 파일을 <code>dist/</code>에 생성한다. 여기서는 concat task에서 생성한 파일을 사용해서 minify를 진행하기 위해서 <code>&lt;%= concat.dis.dest %&gt;</code>를 사용했다.</p>

<p>QUnit 플러그인은 설정이 정말 간단한다. 그냥 QUnit을 실행하는 HTML 실행 파일(test runner)이 있는 위치만 지정하면 된다.</p>

<p><code>javascript
qunit: {
  files: ['test/**/*.html']
},
</code></p>

<p>JSHint 플러그인도 정말 간단한다.</p>

<p>```javascript
jshint: {
  // 검사를 실행할 파일을 지정한다.
  files: [&lsquo;gruntfile.js&rsquo;, &lsquo;src/<strong>/*.js&rsquo;, &lsquo;test/</strong>/*.js&rsquo;],
  // JSHint 환경설정 (<a href="http://www.jshint.com/docs/">http://www.jshint.com/docs/</a> 참고)
  options: {</p>

<pre><code>// 바꾸고 싶은 JSHint 기본값을 여기 지정한다. 
globals: {
  jQuery: true,
  console: true,
  module: true
}
</code></pre>

<p>  }
}
```</p>

<p>JSHint도 파일 목록이 담긴 배열과 옵션 객체만 설정하면 된다. JSHint에 대한 정보는 <a href="http://www.jshint.com/docs/">사이트</a>를 참고한다. JSHint를 기본값으로 잘 써왔다면, Gruntfile에서 재정의 할 필요없다.</p>

<p>끝으로 watch 플러그인을 보자.</p>

<p><code>javascript
watch: {
  files: ['&lt;%= jshint.files %&gt;'],
  tasks: ['jshint', 'qunit']
}
</code></p>

<p>이 task는 컴멘드 라인에 <code>grunt watch</code>를 입력해서 실행할 수 있다. 그러면, 설정한 파일에 어떤 변화가 감지될 때, 지정한 task들을 순서대로 실행한다. (여기서는 JSHint 확인을 위해서 같은 대상파일을 사용했다.)</p>

<p>이제, 필요한 Grunt 플러그인을 불러와야 하는데, 이들은 사전에 npm을 통해서 설치되어있어야 한다.</p>

<p><code>javascript
grunt.loadNpmTasks('grunt-contrib-uglify');
grunt.loadNpmTasks('grunt-contrib-jshint');
grunt.loadNpmTasks('grunt-contrib-qunit');
grunt.loadNpmTasks('grunt-contrib-watch');
grunt.loadNpmTasks('grunt-contrib-concat');
</code></p>

<p>그리고 나서 task를 몇 개 설정한다. 가장 중요한건 default task다.</p>

<p>```javascript
// 컴멘드 라인에 &ldquo;grunt test"를 입력하면 실행된다.
grunt.registerTask(&lsquo;test&rsquo;, [&lsquo;jshint&rsquo;, &lsquo;qunit&rsquo;]);</p>

<p>// default task는 컴멘드 라인에 &ldquo;grunt"만 입력했을 때 실행할 task들이다.
grunt.registerTask(&lsquo;default&rsquo;, [&lsquo;jshint&rsquo;, &lsquo;qunit&rsquo;, &lsquo;concat&rsquo;, &lsquo;uglify&rsquo;]);
```</p>

<p>전체 <code>Gruntfile.js</code>다.</p>

<p>```javascript
module.exports = function(grunt) {</p>

<p>  grunt.initConfig({</p>

<pre><code>pkg: grunt.file.readJSON('package.json'),
concat: {
  options: {
    separator: ';'
  },
  dist: {
    src: ['src/**/*.js'],
    dest: 'dist/&lt;%= pkg.name %&gt;.js'
  }
},
uglify: {
  options: {
    banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("dd-mm-yyyy") %&gt; */\n'
  },
  dist: {
    files: {
      'dist/&lt;%= pkg.name %&gt;.min.js': ['&lt;%= concat.dist.dest %&gt;']
    }
  }
},
qunit: {
  files: ['test/**/*.html']
},
jshint: {
  files: ['Gruntfile.js', 'src/**/*.js', 'test/**/*.js'],
  options: {
    // options here to override JSHint defaults
    globals: {
      jQuery: true,
      console: true,
      module: true,
      document: true
    }
  }
},
watch: {
  files: ['&lt;%= jshint.files %&gt;'],
  tasks: ['jshint', 'qunit']
}
</code></pre>

<p>  });</p>

<p>  grunt.loadNpmTasks(&lsquo;grunt-contrib-uglify&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-jshint&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-qunit&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-watch&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-concat&rsquo;);</p>

<p>  grunt.registerTask(&lsquo;test&rsquo;, [&lsquo;jshint&rsquo;, &lsquo;qunit&rsquo;]);</p>

<p>  grunt.registerTask(&lsquo;default&rsquo;, [&lsquo;jshint&rsquo;, &lsquo;qunit&rsquo;, &lsquo;concat&rsquo;, &lsquo;uglify&rsquo;]);</p>

<p>};
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt: Configuring tasks in korean]]></title>
    <link href="http://zziuni.github.io/blog/2013/11/17/grunt-configuring-tasks-in-korean/"/>
    <updated>2013-11-17T00:29:00+09:00</updated>
    <id>http://zziuni.github.io/blog/2013/11/17/grunt-configuring-tasks-in-korean</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://gruntjs.com">Grunt</a>은 Javascript Task Runner 입니다. 이 문서는 Grunt 공식 사이트의 <a href="http://gruntjs.com/configuring-tasks">Configuring Tasks</a>를 번역한 문서이며 grunt-cli의 버전이 0.1.10일 때 번역했습니다.</p></blockquote>

<h1>Configuring tasks</h1>

<p>이 문서는 <code>Gruntfile</code>를 사용하는 프로젝트를 위해서 task 단위로 환경설정을 하는 법을 설명한다. <code>Gruntfile</code>에 대해 잘 모른다면 <a href="http://gruntjs.com/getting-started">Getting Started</a> (<a href="http://zziuni.github.io/blog/2013/10/13/grunt-getting-started-in-korean/">번역문</a>)문서를 먼저 읽어보고 <a href="http://gruntjs.com/sample-gruntfile">Gruntfile 샘플</a> 파일을 체크아웃 받자.</p>

<h2>Grunt Configuration</h2>

<p>task 환경설정은 <code>Gruntfile</code>에서 <code>grunt.initConfig</code> 메서드를 통해서 지정한다. 일반적으로 환경설정은 task 명과 동일한 프로퍼티의 값으로 설정한다. 여러분이 설정한 task의 이름들과 충돌하지만 않으면 얼마든지 임의의 데이터를 넣을 수 있다. 물론 무시되지만.</p>

<!-- more -->


<p>또한, 이 파일은 JSON이 아닌 자바스크립트 파일이기 때문에, 모든 자바스크립트 코드를 사용할 수 있다. 필요하다면 동적으로 환경설정을 생성할 수도 있다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    // concat task를 위한 환경설정은 여기에 넣는다.
  },
  uglify: {
    // uglify task를 위한 환경설정은 여기에 넣는다. 
  },
  // 특정 task와 관련없는 임의의 프로퍼티
  my_property: 'whatever',
  my_src_files: ['foo/*.js', 'bar/*.js'],
});
</code></pre>

<p>```</p>

<h2>Task Configuration and Targets</h2>

<p>task 하나가 실행되면, Grunt는 그 task의 이름으로 <code>Gruntfile</code>의 환경설정 객체에서 프로퍼티를 찾고 이를 해당 task의 환경설정으로 사용한다. 여러 일을 한 번에 하는 multi-task는 다시 별도의 target 명을 사용해서 환경설정을 개별적으로 가질 수 있다. 다음 예제를 보면 <code>uglify</code> task는 <code>bar</code> target만 가지고 있지만, <code>concat</code> task는 <code>foo</code>와 <code>bar</code>라는 두 개의 target을 갖고 있다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    foo: {
      // concat task의 "foo" 타겟을 위한 옵션과 파일을 여기에 넣는다. 
    },
    bar: {
      // concat task의 "bar" 타겟을 위한 옵션과 파일을 여기에 넣는다. 
    },
  },
  uglify: {
    bar: {
      // uglify task의 "bar" 타겟을 위한 옵션과 파일을 여기에 넣는다. 
    },
  },
});
</code></pre>

<p>```</p>

<p><code>grunt concat</code>를 입력하면 모든 target을 순회하며, 차례대로 모든 target의 환경설정을 가져오는 반면에, <code>grunt concat:foo</code>나 <code>grunt concat:bar</code>처럼 task와 target을 모두 사용해서 지정하면 특정 target의 환경설정만 가져온다. 단, task 명이 <strong>grunt.renameTask</strong>로 변경되면, Grunt는 새로운 task 명으로 config 객체에서 프로퍼티 명을 찾는다.</p>

<h2>Options</h2>

<p>task 환경설정 하나를 살펴보자, <code>options</code> 프로퍼티는 내장된 기본값을 재정의 하기 위해서 덮어 쓸 때 사용한다. 그리고 각 target 별로도 해당 target에만 한정된 <code>options</code> 프로퍼티를 가질 수 있다. target 레벨의 options는 해당 타겟 레벨에서만 덮어써진다.</p>

<p><code>options</code> 프로퍼티는 필수요소가 아니며, 필요없는 경우 무시된다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    options: {
      // task 수준의 옵션 객체. task 기본값을 덥어쓴다. 
    },
    foo: {
      options: {
        // "foo" target 수준의 옵션 객체. task 수준의 options을 덥어쓴다. 
      },
    },
    bar: {
      // 명시된 options가 없다. 이 target은 task 수준의 options을 사용한다.
    },
  },
});
</code></pre>

<p>```</p>

<h2>Files</h2>

<p>대부분의 task는 파일을 대상으로하는 작업들이므로, Grunt는 task가 작업 대상 파일을 선언하기 위한 추상화된 기능을 강력하게 지원한다. <strong>src-dest</strong>(출처와 목적지)간의 파일 매핑을 정의하는 방법은 여러 가지가 있다. 매핑의 표현과 제어도 지속적으로 변경 가능하면서 말이다.
이제부터 설명할 유형들은 모든 task에서 사용할 수 있으므로, 여러분 상황에 맞는 포맷을 선택하면 된다.</p>

<p><code>src</code>와 <code>dest</code>는 모두 파일 포맷에서 지원하지만 &ldquo;Compact"와 "Files Array&rdquo; 포맷에서는 몇 가지 추가 프로퍼티를 사용할 수 있다.</p>

<ul>
<li><code>fileter</code>: 필터용도로 유효한 <a href="http://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats">fs.Stats 메서드명</a>이나 함수를 적용한다. 이때, 함수는 적절한 <code>src</code> 파일경로를 받으면 <code>true</code>나 <code>false</code>를 반환해야 한다.</li>
<li><code>nonull</code>: <code>true</code>를 지정했을 때는 패턴과 일치하는 내용이 없는 경우, 그 패턴 자체를 담은 목록을 반환하고, <code>false</code>를 지정했을 때는 패턴과 일치하는 내용이 없는 경우, 빈 목록을 반환한다. <code>--verbos</code>와 함께 사용하면 파일 경로 관련 버그를 찾을 때 유용하다.</li>
<li><code>dot</code>: <code>true</code>면 패턴에 명시적으로 포함시키지 않아도 구두점(.)으로 시작하는 파일명을 일치시킨다.(src/*.js 하면 hidden files도 포함된다는 말.)</li>
<li><code>matchBase</code>: <code>true</code>면, 슬래시(/)를 포함하지 않은 패턴들이 슬래시를 가지고 있을 경로 기본명을 제외하고 매치된다. 예를 들어 <code>a?b</code> 패턴이 <code>/xyz/acb/123</code>이 아니라 <code>/xyz/123/acb</code>와 일치한다.</li>
<li><code>expand</code>은 동적인 src-dest 파일 매핑을 수행한다. 더 자세한 정보는 <a href="http://gruntjs.com/configuring-tasks#building-the-files-object-dynamically">Building the files object dynamically</a>를 참고한다.</li>
<li>이 이외의 프로퍼티들은 매칭 옵션으로 하위 libs로 전달된다. 추가 옵션은 <a href="https://github.com/isaacs/node-glob">node-glob</a>와 <a href="https://github.com/isaacs/minimatch">minimatch</a>를 보자.</li>
</ul>


<h3>Compact Format</h3>

<p>이 형태는 target 별로 단일 <strong>src-dest</strong> 파일 매핑을 할 때 사용한다. 주로 <a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint</a>처럼 <code>dest</code>와 관계없이 <code>src</code> 프로퍼티 하나만 필요한 읽기 전용 task를 위해서 사용한다. src-dest 파일 매핑 별로 프로퍼티 확장도 가능하다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  jshint: {
    foo: {
      src: ['src/aa.js', 'src/aaa.js']
    },
  },
  concat: {
    bar: {
      src: ['src/bb.js', 'src/bbb.js'],
      dest: 'dest/b.js',
    },
  },
});
</code></pre>

<p>```</p>

<h3>Files Object Format</h3>

<p>이 형태는 target 별로 다중 src-dest 매핑을 할 때 사용한다. 프로퍼티 명이 목적지(destination) 파일명이고 프로퍼티 값은 출처(source) 파일이 된다. 이 방법을 사용하면 src-dest 파일 매핑이 아무리 많아도 지정할 수 있다. 하지만 매핑 별로 추가 파라미터 지정은 불가능하다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    foo: {
      files: {
        'dest/a.js': ['src/aa.js', 'src/aaa.js'],
        'dest/a1.js': ['src/aa1.js', 'src/aaa1.js'],
      },
    },
    bar: {
      files: {
        'dest/b.js': ['src/bb.js', 'src/bbb.js'],
        'dest/b1.js': ['src/bb1.js', 'src/bbb1.js'],
      },
    },
  },
});
</code></pre>

<p>```</p>

<h3>Files Array Format</h3>

<p>이 형태는 target 별로 다중 src-dest 매핑을 지원하면서 매핑 별로 추가 프로퍼티를 사용할 수 있다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    foo: {
      files: [
        {src: ['src/aa.js', 'src/aaa.js'], dest: 'dest/a.js'},
        {src: ['src/aa1.js', 'src/aaa1.js'], dest: 'dest/a1.js'},
      ],
    },
    bar: {
      files: [
        {src: ['src/bb.js', 'src/bbb.js'], dest: 'dest/b/', nonull: true},
        {src: ['src/bb1.js', 'src/bbb1.js'], dest: 'dest/b1/', filter: 'isFile'},
      ],
    },
  },
});
</code></pre>

<p>```</p>

<h3>Older Formats</h3>

<p><strong>dest as targets</strong> 파일 형태는 멀티 task와 target가 있기 전부터 있던 형태로 목적지(destination) 파일 경로가 그대로 target 명이 된다. 하지만 이 때문에 <code>grunt task:target</code>의 형태로 동작시키기가 거북할 수 있다. 또한 src-dest 매핑 별로 target 수준의 옵션이나 추가 프로퍼티를 지정할 수 없다.</p>

<p>이 형태는 되도록 사용하지 말고 가능하면 피하자.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    'dest/a.js': ['src/aa.js', 'src/aaa.js'],
    'dest/b.js': ['src/bb.js', 'src/bbb.js'],
  },
});
</code></pre>

<p>```</p>

<h3>Custom Filter Function</h3>

<p><code>filter</code> 프로퍼티를 사용하면 파일을 좀 더 꼼꼼하게 지정할 수 있다. 그냥 적절한 <a href="http://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats">fs.Stats 메서드명</a>을 사용하자. 다음 예제는 패턴과 일치하는 파일만 제거(clean)한다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  clean: {
    foo: {
      src: ['tmp/**/*'],
      filter: 'isFile',
    },
  },
});
</code></pre>

<p>```</p>

<p>아니면 파일 일치 여부에 따라 <code>true</code>, <code>false</code>를 반환하는 <code>filter</code>용 함수를 생성하자. 다음 예제는 빈 폴더만 지우는 필터다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  clean: {
    foo: {
      src: ['tmp/**/*'],
      filter: function(filepath) {
        return (grunt.file.isDir(filepath) &amp;&amp; require('fs').readdirSync(filepath).length === 0);
      },
    },
  },
});
</code></pre>

<p>```</p>

<h3>Globbing patterns</h3>

<p>대상(source) 파일 경로를 모두 개별적으로 지정하는 일이 불가능할 때도 있다. 그래서 Grunt는 <a href="https://github.com/isaacs/node-glob">node-glob</a>와 <a href="https://github.com/isaacs/minimatch">minimatch</a>라이브러리를 내부에 포함시켰고, 이를 통해서 파일명 확장을 지원한다. (globbing이라고도 한다.)</p>

<p>이 문서는 globbing 패턴 전반을 다루는 튜토리얼이 아니므로, 파일경로에서 사용할 수 있는 몇 가지만 소개한다.</p>

<ul>
<li><code>*</code>는 개수와 관계없이 <code>/</code>를 제외한 모든 캐릭터와 일치한다.</li>
<li><code>?</code>는 <code>/</code>를 제외한 하나의 캐릭터와 일치한다.</li>
<li><code>**</code>는 개수와 관계없이 <code>/</code>를 포함한 모든 캐릭터와 일치한다. 하지만 경로부분(폴더명)에서만 동작한다.</li>
<li><code>{}</code>에 콤마로 구분된 목록을 넣으면 &ldquo;or&rdquo; 표현식으로 동작한다.</li>
<li><code>!</code>를 패턴의 처음에 사용하면 불일치(negative match)를 의미한다.</li>
</ul>


<p>globbing 패턴을 잘 모르더라도 <code>foo/*.js</code>는 <code>foo/</code> 폴더에서 <code>.js</code>로 끝나는 모든 파일과 일치하지만, <code>foo/**/*.js</code>는 <code>foo/</code> 폴더와 그 아래의 모든 하위 폴더에서 <code>.js</code>로 끝나는 모든 파일과 일치한다는 것 정도는 알아두면 좋다.</p>

<p>globbing 패턴의 복잡함을 줄이기 위해서, Grunt에서는 파일 경로나 globbing 패턴을 배열로 지정할 수 있다. 패턴은 모두 배열의 색인 순서대로 처리되는데, 결과 집합에서 일치하는 파일을 제외하는 <code>!</code> 접두사 패턴도 마찬가지다. 최종 결과 집합은 중복값이 없는 유일값들이다.</p>

<p>예제을 보자.</p>

<p>```javascript</p>

<pre><code>// 단일 파일 지정. 
{src: 'foo/this.js', dest: ...}
// 배열로 여러 파일 지정.
{src: ['foo/this.js', 'foo/that.js', 'foo/the-other.js'], dest: ...}
// glob 패턴 사용.
{src: 'foo/th*.js', dest: ...}

// 단일 node-glob 패턴.
{src: 'foo/{a,b}*.js', dest: ...}
// 물론 이렇게도 사용 가능.
{src: ['foo/a*.js', 'foo/b*.js'], dest: ...}

// foo/ 안의 모든 .js 파일. 순서는 알파벳 순.
{src: ['foo/*.js'], dest: ...}
// bar.js을 먼저 선택하고, 남은 파일을 알파벳 순으로 추가.
{src: ['foo/bar.js', 'foo/*.js'], dest: ...}

// bar.js를 제외한 모든 파일. 알파벳 순.
{src: ['foo/*.js', '!foo/bar.js'], dest: ...}
// 모든 파일을 알파벳 순서로 넣고, 끝에 bar.js를 추가.
{src: ['foo/*.js', '!foo/bar.js', 'foo/bar.js'], dest: ...}

// 파일경로나 glob 패턴에 템플릿(&lt;%%&gt;)을 사용할 수도 있다.
{src: ['src/&lt;%= basename %&gt;.js'], dest: 'build/&lt;%= basename %&gt;.min.js'}
// 환경설정의 다른 task의 target에서 정의한 파일 목록을 참조할 수도 있다.
{src: ['foo/*.js', '&lt;%= jshint.all.src %&gt;'], dest: ...}
</code></pre>

<p>```</p>

<p>더 자세한 glob 패턴 문법은 <a href="https://github.com/isaacs/node-glob">node-glob</a>와 <a href="https://github.com/isaacs/minimatch">minimatch</a> 문서를 참고하자.</p>

<h3>Building the fiels object dynamically</h3>

<p>대량의 파일들을 처리하고자 할 때, 파일 목록을 동적으로 생성하는데 사용가능한 몇 가지 추가 프로퍼티들이 있다. 이 프로퍼티들은 &ldquo;Compact"와 "Files Array&rdquo; 매핑 패턴에 지정할 수 있다.</p>

<ul>
<li><code>expand</code>: 다음 옵션들을 활성화하려면 먼저 이 프로퍼티를 <code>true</code>로 설정한다.</li>
<li><code>cwd</code>: 모든 <code>src</code> 패턴을 이 옵션에 정의된 경로를 기준으로 정한다.</li>
<li><code>src</code>: 일치 여부 확인을 위한 패턴 목록. <code>cwd</code>기준 상대경로.</li>
<li><code>dest</code>: 목적지 지정을 위한 경로 접두사.</li>
<li><code>ext</code>: <code>dest</code> 경로에 생성할 파일의 확장자.</li>
<li><code>flatten</code>: <code>dest</code> 경로에 생성할 목록에서 경로부분을 제거하고 파일명만 남긴다.</li>
<li><code>rename</code>: 일치하는 <code>src</code> 파일별로 호출되는 함수. 이 함수는 (확장자 변경과 경로 제거 후) 일치하는 <code>src</code> 패턴과 <code>dest</code>를 인자로 받아서, 새로운 <code>dest</code> 값을 반환해야 한다. 동일 <code>dest</code> 값이 여러 번 반환되면, 사용된 <code>src</code>들이 이름변경을 위한 출처 배열에 추가된다.</li>
</ul>


<p>다음 <code>minify</code> task 예제는 <code>static_mappings</code>와 <code>dynamic_mappings</code> target에서 동일한 src-dest 파일 매핑을 바라보고 있다. task를 실행하면, Grunt는 자동으로 <code>dynamic_mappings</code> 파일 목록을 정적인 4개의 src-dest 파일 매핑으로 바꾼다.</p>

<p>또한, 정적인 매핑과 동적인 매핑은 다양한 방법으로 함께 쓸 수 있다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  minify: {
    static_mappings: {
      // 이 src-dest 파일 매핑은 수동으로 지정했기 때문에, 
      // 파일 추가 삭제와 Grunfile 수정을 매번 해줘야 한다.
      files: [
        {src: 'lib/a.js', dest: 'build/a.min.js'},
        {src: 'lib/b.js', dest: 'build/b.min.js'},
        {src: 'lib/subdir/c.js', dest: 'build/subdir/c.min.js'},
        {src: 'lib/subdir/d.js', dest: 'build/subdir/d.min.js'},
      ],
    },
    dynamic_mappings: {
      // "minify" task가 실행되면 Grunt는 "lib/" 아래에서 "**/*.js"를 찾는다. 
      // 그렇게 찾은 src-dest 파일 매핑으로 빌드한다. 
      // 파일이 추가/제거 될 때 마다 Gruntfile을 수정할 필요없다.
      files: [
        {
          expand: true,     // 동적 기술법을 활성화.
          cwd: 'lib/',      // Src 패턴의 기준 폴더.
          src: ['**/*.js'], // 비교에 사용할 패턴 목록.
          dest: 'build/',   // 목적 경로의 접두사(사실상 폴더명)
          ext: '.min.js',   // dest의 파일들의 확장자.
        },
      ],
    },
  },
});
</code></pre>

<p>```</p>

<h2>Templates</h2>

<p><code>&lt;%%&gt;</code> 구분자를 사용한 템플릿은 task가 해당 환경설정을 읽어올 때 자동으로 정적인 값으로 기술된다. 그리고 이는 템플릿를 모두 기술될 때 까지 재귀적으로 실행된다.</p>

<p><code>grunt.initConfig()</code>의 환경설정 객체는 프로퍼티 설정시 컨텍스트로 사용되며, <code>grunt</code>와 그 메서드도 그 안에서 사용할 수 있다. 예) <code>&lt;%= grunt.template.today('yyyy-mm-dd') %&gt;</code></p>

<ul>
<li><code>&lt;%= prop.subprop%&gt;</code>는 환경설정 객체에서 <code>prop.subprop</code>을 찾아서 그 값으로 치환된다. 타입은 관계없다. 이같은 템플릿은 문자열 만이 아니라 배열과 다른 객체로 참조할 수도 있다.</li>
<li><code>&lt;% %&gt;</code>는 임의의 인라인 자바스크립트 코드를 실행한다. 그래서 흐름제어나 순회를 위해 사용할 수 있다.</li>
</ul>


<p>여기 <code>concat</code> task가 있다. <code>grunt concat:sample</code>을 실행하면 <code>foo/*.js</code> + <code>bar/*.js</code> + <code>baz/*.js</code>와 일치하는 파일을 합치고 <code>/* abcde */</code> 상단 주석(banner)를 추가해서 <code>build/abcde.js</code>란 이름으로 생성한다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  concat: {
    sample: {
      options: {
        banner: '/* &lt;%= baz %&gt; */\n',   // '/* abcde */\n'
      },
      src: ['&lt;%= qux %&gt;', 'baz/*.js'],  // [['foo/*.js', 'bar/*.js'], 'baz/*.js']
      dest: 'build/&lt;%= baz %&gt;.js',      // 'build/abcde.js'
    },
  },
  // task 환경설정 템플릿에 사용되는 임의의 프로퍼티들
  foo: 'c',
  bar: 'b&lt;%= foo %&gt;d', // 'bcd'
  baz: 'a&lt;%= bar %&gt;e', // 'abcde'
  qux: ['foo/*.js', 'bar/*.js'],
});
</code></pre>

<p>```</p>

<h2>Importing External Data</h2>

<p>다음 <code>Gruntfile</code> 파일은 <code>package.json</code> 파일에서 프로젝트 관련 메타데이터를 가져온다. 그리고 그 메타데이터를 <a href="http://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify 플러그인</a>의 <code>uglify</code> task의 상단 주석 생성과 src 파일 minify를 위한 정보로 사용한다.</p>

<p>Grunt는 JSON과 YAML 데이터를 가져올 수 있는 <code>grunt.file.readJSON</code>와 <code>grunt.file.readYAML</code>를 지원한다.</p>

<p>```javascript</p>

<pre><code>grunt.initConfig({
  pkg: grunt.file.readJSON('package.json'),
  uglify: {
    options: {
      banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'
    },
    dist: {
      src: 'src/&lt;%= pkg.name %&gt;.js',
      dest: 'dist/&lt;%= pkg.name %&gt;.min.js'
    }
  }
});
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt: Getting started in korean]]></title>
    <link href="http://zziuni.github.io/blog/2013/10/13/grunt-getting-started-in-korean/"/>
    <updated>2013-10-13T00:01:00+09:00</updated>
    <id>http://zziuni.github.io/blog/2013/10/13/grunt-getting-started-in-korean</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://gruntjs.com">Grunt</a>은 Javascript Task Runner 입니다. 이 문서는 Grunt 공식 사이트의 <a href="http://gruntjs.com/getting-started">Getting Started</a>를 번역한 문서이며 grunt-cli의 버전이 0.1.7일 때 번역했습니다.</p></blockquote>

<h1>Getting started</h1>

<p><img src="http://gruntjs.com/img/grunt-logo.svg" alt="" /></p>

<p>Grunt와 Grunt 플러그인의 설치와 관리는 <a href="https://npmjs.org">npm</a>을 통해서 한다. npm은 <a href="http://nodejs.org">Node.js</a>의 패키지 메니징 도구다.</p>

<p>Grunt 0.4.x를 사용하려면 Node.js 버전이 <code>&gt;=0.8.0</code> 이여야 한다.</p>

<h2>Installing the CLI</h2>

<p><strong>Grunt 0.3을 이미 사용하고 있고 0.4.x로 업그레이드 하는 거라면, <a href="http://gruntjs.com/getting-started#grunt-0.3-notes">Grunt 0.3 Notes</a> 문서를 먼저 보자.</strong></p>

<p>Grunt를 사용하려면 먼저 Grunt&rsquo;s Command line interface (CLI)를 설치해야 한다. 이때 OSX나 nix, BSD에서는 sudo가, 윈도우즈에서는 administrator 권한이 필요할 수도 있다.</p>

<pre><code>npm install -g grunt-cli
</code></pre>

<p><code>grunt-cli</code>를 설치하면 여러분의 시스템 경로에 자동으로 <code>grunt</code>를 추가해서, 어느 디렉토리에서나 <code>grunt</code>를 사용할 수 있게 만든다.</p>

<!-- more -->


<p>하지만 <code>grunt-cli</code>는 Grunt task runner(즉, <code>grunt</code>)를 설치하지는 않는다. Grunt CLI의 역할은 간단하다. <code>Gruntflie</code>라는 파일이 있는 위치에 설치된 Grunt를 실행하는 것이다. 즉, 같은 장비에서 여러 버전의 Grunt를 설치할 수 있다.</p>

<h2>How the CLI works</h2>

<p><code>grunt</code>를 실행하면 grunt-cli는 node의 <code>require()</code>를 사용해서 프로젝트 로컬의 grunt를 실행한다. 그러므로 프로젝트 루트 폴더가 아니여도 하위 폴더 어디서든 <code>grunt</code>를 실행할 수 있다.</p>

<p>특정 위치에 설치된 Grunt를 찾으면, CLI는 Grunt 라이브러리의 로컬 인스톨본을 불러온다. 이때 <code>Gruntfile</code>라는 파일로 환경설정을 적용하고, 특정 동작을 위해 설정한 task들을 실행한다.</p>

<p>이때 일어라는 일이 궁금하면 <a href="https://github.com/gruntjs/grunt-cli/blob/master/bin/grunt">코드</a>를 읽어보자. 겁나 짧다.</p>

<h2>Preparing a new grunt project</h2>

<p>일반적인 설치과정에서는 프로젝트에 <code>package.json</code>과 <code>Grunfile</code>라는 파일이 있어야 한다.</p>

<p><strong>package.json</strong>: 이 파일은 <a href="https://npmjs.org/">npm</a>이 해당 프로젝트를 npm 모듈로 퍼블리싱할 때 사용하는 메타데이터 저장 파일이다. 이 파일의 <a href="https://npmjs.org/doc/json.html#devDependencies">devDependencies</a> 항목에 프로젝트에 필요한 grunt와 Grunt 플러그인들을 나열할 수 있다.</p>

<p><strong>Gruntfile</strong>: 이 파일의 이름은 <code>Gruntfile.js</code>이거나 <code>Gruntfile.coffee</code>이다. task를 설정하거나 정의하고 Grunt 플러그인을 불러오는데 사용한다.</p>

<h3>package.json</h3>

<p><code>package.json</code>파일은 <code>Gruntfile</code>과 함께 프로젝트 루트 디렉토리에 있어야 하고, 프로젝트 소스와 함께 커밋(commit)되야 한다. <code>package.json</code>이 있는 폴더에서 컴맨드 명령어 <code>npm install</code>를 실행하면 이 파일 안에 있는 dependency 목록의 모듈들을 해당 버전으로 인스톨한다.</p>

<p>프로젝트에 <code>package.json</code>를 추가하는 방법은 여러가지가 있다.</p>

<ul>
<li>대부분의 <a href="http://gruntjs.com/project-scaffolding#h5o-9">grunt-init</a> 템플릿은 자동으로 프로젝트 전용  <code>package.json</code>파일을 생성한다.</li>
<li><a href="https://npmjs.org/doc/init.html">npm init</a> 컴맨드 명령어는 기본 <code>package.json</code>을 생성한다.</li>
<li>다음 예제를 기초로 필요한 부분은 <a href="https://npmjs.org/doc/json.html">specification</a> 문서를 참고 해서 확장한다.</li>
</ul>


<p>```javascript</p>

<pre><code>{
  "name": "my-project-name",
  "version": "0.1.0",
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-contrib-jshint": "~0.6.3",
    "grunt-contrib-nodeunit": "~0.2.0",
    "grunt-contrib-uglify": "~0.2.2"
  }
}
</code></pre>

<p>```</p>

<h4>Installing Grunt and gruntplugins</h4>

<p>Grunt와 플러그인을 설치와 동시에 <code>package.json</code>와 연동시키려면 <code>npm install &lt;module&gt; --save-dev</code> 컴맨드 명령어를 사용한다. 이러면 <code>&lt;module&gt;</code>만 설치하고 끝나지 않고, 자동으로 <code>package.json</code>의 <a href="https://npmjs.org/doc/json.html#devDependencies">devDependencies</a> 항목에 추가된다. 버전은 <a href="https://npmjs.org/doc/json.html#version">tiled version range</a>를 사용한다.</p>

<p>예를 들면, 다음 컴맨드 명령어는 프로젝트에 Grunt 최신버전을 설치하고 <code>package.json</code>의 devDependencies 항목에 grunt를 추가한다.</p>

<pre><code>npm install grunt --save-dev
</code></pre>

<p>grunt 플러그인과 다른 node 모듈도 마찬가지다. 이렇게 설치하면 프로젝트의 <code>package.json</code>이 갱신된다.</p>

<h3>The Gruntfile</h3>

<p><code>Gruntfile.js</code>나 <code>Gruntfile.coffee</code>파일은 프로젝트 루트 폴더에 있어야 하는 자바스크립트 혹은, 커피스크립트 파일이다. 그리고 이 파일은 프로젝트 소스의 일부로 같이 커밋되야 한다.</p>

<p>다음은 <code>Gruntfile</code>의 내부 구성요소다.</p>

<ul>
<li>&ldquo;wrapper&rdquo; 함수.</li>
<li>프로젝트와 task의 환경설정.</li>
<li>grunt plugin과 task 로딩.</li>
<li>사용자 정의 task</li>
</ul>


<h4>An sample Gruntfile</h4>

<p>다음 <code>Gruntfile</code>은 프로젝트의 메타데이터를 <code>package.json</code>에서 가져와서 Grunt config로 주입한다. 그리고 <a href="http://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a> 플러그인의 <code>uglify</code> task을 사용해서 소스코드를 미니파이(minify)하도록 설정하고, 메타데이터를 이용해서 동적인 베너 주석도 생성한다. 그리고 <code>uglify</code> task를 컴맨드 라인에서 <code>grunt</code> 명령어를 실행할 때 실행되는 기본 task로 지정했다.</p>

<p>```javascript</p>

<pre><code>module.exports = function(grunt) {

  // Project configuration.
  grunt.initConfig({
    pkg: grunt.file.readJSON('package.json'),
    uglify: {
      options: {
        banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'
      },
      build: {
        src: 'src/&lt;%= pkg.name %&gt;.js',
        dest: 'build/&lt;%= pkg.name %&gt;.min.js'
      }
    }
  });

  // Load the plugin that provides the "uglify" task.
  grunt.loadNpmTasks('grunt-contrib-uglify');

  // Default task(s).
  grunt.registerTask('default', ['uglify']);

};
</code></pre>

<p>```</p>

<p>이 코드가 <code>Grunfile</code> 전체 코드다. 파트별로 살펴보자.</p>

<h4>The &ldquo;wrapper&rdquo; function</h4>

<p>모든 <code>Gruntfile</code>(그리고 그 플러그인)은 래퍼(wrapper) 함수를 기본 형태로 사용한다. 모든 Grunt 코드는 이 함수 안쪽에 있어야 한다.</p>

<p>```javascript</p>

<pre><code>module.exports = function(grunt){
    // Do grunt-related things in here
}
</code></pre>

<p>```</p>

<h4>Project and task configuration</h4>

<p>대부분의 Grunt task는 configuration을 위한 데이터로 <a href="http://gruntjs.com/grunt#grunt.initconfig">grunt.initConfig</a> 메서드의 인자로 전달되는 객체를 사용한다.(이를 configuraton 객체라 하자.)</p>

<p>위의 예제에서, <code>grunt.file.readJSON('package.json')</code> 코드는 grunt config로 <code>package.json</code>에 저장된 JOSN 메타데이터를 인포트한다. 그러면 <code>&lt;% %&gt;</code> 템플릿 문자열을 사용해서 config의 모든 프로퍼티를 참조할 수 있다.(<code>package.json</code>값을 불러올 수 있다는 말이다.) 파일패스나 파일 목록 같은 configuration 데이터는 반복을 줄이기 위해서 이 방법으로 지정한다.</p>

<p>여러분의 task가 필요로하는 프로퍼티와 충돌하지 않는 이상 configuraton 객체안에는 어떤 값을 넣어도 상관없다. 그리고 이 파일은 단순 JSON이 아닌 자바스크립트 파일이므로, 유효한 JS코드는 모두 사용가능하다. 즉, 필요한 configuration을 동적으로 생성할 수도 있다.</p>

<p>다른 task도 마찬가지지만, <a href="http://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a> 플러그인의 <code>uglify</code> task는 configuration 객체에서 동명의 프로퍼티 명(uglify)으로 설정에 필요한 값을 찾는다. 여기서는 옵션값인 <code>banner</code>와 소스파일(src) 하나를 타겟파일(dest) 하나로 미니파이(minify)하는 어그리파이(uglify) 타겟명인 <code>build</code>를 지정했다.</p>

<p>```javascript</p>

<pre><code>// Project configuration.
grunt.initConfig({
  pkg: grunt.file.readJSON('package.json'),
  uglify: {
    options: {
      banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'
    },
    build: {
      src: 'src/&lt;%= pkg.name %&gt;.js',
      dest: 'build/&lt;%= pkg.name %&gt;.min.js'
    }
  }
});
</code></pre>

<p>```</p>

<h4>Loading grunt plugins and tasks</h4>

<p>자주 사용하는 <a href="https://github.com/gruntjs/grunt-contrib-concat">concatenation</a>, <a href="http://github.com/gruntjs/grunt-contrib-uglify">minification</a>, <a href="https://github.com/gruntjs/grunt-contrib-jshint">linting</a>같은 task들은 <a href="https://github.com/gruntjs">grunt plugin</a>으로 설정해서 사용할 수 있다. 즉, <code>package.json</code>의 dependency에 플러그인을 설정했다면, <code>npm install</code>을 통해서 이미 설치된 것이므로, 간단한 코드 추가로 <code>Gurntfile</code>에서 사용 가능하다.</p>

<p>```javascript</p>

<pre><code>// Load the plugin that provides the "uglify" task.
grunt.loadNpmTasks('grunt-contrib-uglify');
</code></pre>

<p>```</p>

<p><strong>참고</strong>: <code>grunt --help</code> 명령어를 사용하면 사용가능한 taks 목록을 볼 수 있다.</p>

<h4>Custom tasks</h4>

<p><code>default</code> task를 설정하면 기본으로 실행할 task를 하나 혹은 그 이상 지정할 수 있다. 예를 들면, 컴맨드 라인에 특정 task를 지정하지 않고 <code>grunt</code>만 입력하면 <code>uglify</code> task가 실행된다. 이는 실제로는 <code>grunt uglify</code>나 <code>grunt default</code>와 같다. 배열 안에는 다수의 task를 지정할 수도 있다. (아규먼트는 있을 수도 있고 없을 수도 있다.)</p>

<p>```javascript</p>

<pre><code>// Default task(s)
grunt.registerTask('default', ['uglify']);
</code></pre>

<p>```</p>

<p>만약 프로젝트에서 Grunt 플러그인 목록에 없는 task가 필요하다면, <code>Gruntfile</code>에 직접 custom task를 만들 수도 있다. 예를 들면, 다음 <code>Gruntfile</code>은 task configuration을 전혀 활용하지 않는 custom <code>default</code> task를 정의한다.</p>

<p>```javascript</p>

<pre><code>module.exports = function(grunt){

      // A very basic default task.
      grunt.registorTask('default', 'Long some stuff', function() {
          grunt.log.write('Logging some stuff...').ok();
      });
};
</code></pre>

<p>```</p>

<p>프로젝트 전용 task라면 <code>Gruntfile</code>안에 정의할 필요없이. 별도의 <code>.js</code> 파일로 정의하고 <a href="http://gruntjs.com/grunt#grunt.loadtasks">grunt.loadTask</a> 메서드로 불러와도 된다.</p>

<h3>Further Reading</h3>

<ul>
<li><a href="http://gruntjs.com/installing-grunt/">Installing grunt</a> 가이드는 인스톨 스펙, 프로덕션, 개발, Grunt와 grunt-cli의 버전에 대한 상세한 정보를 제공한다.</li>
<li><a href="http://gruntjs.com/configuring-tasks/">Configuring Tasks</a> 가이드는 <code>Gruntfile</code>에서 task, target, option, file을 설정하는 방법을 상세하게 설명한다. tempaltes, globbing pattern, importing external data도 설명한다.</li>
<li><a href="http://gruntjs.com/creating-tasks/">Creating Tasks</a> 가이드에는 Grunt task의 타입간의 차이점 목록이 있으며, task와 configuration의 샘플도 제공한다.</li>
<li>custom task나 Grunt 플러그인에 대한 더 많은 정보는 <a href="http://gruntjs.com/grunt">developer documentation</a>을 확인하자.</li>
</ul>


<h3>Grunt 0.3 Notes</h3>

<p>Grunt 0.3에서 업그레이드 할거라면 전역 <code>grunt</code>를 제거해야 한다.</p>

<p>```javascript</p>

<pre><code>npm install -g grunt
</code></pre>

<p>```</p>

<p><em>이 안내서는 Grunt 0.4.x를 위해 작성되었다. 그렇다고 Grunt 0.3.x에서 참고할 수 없는건 아니다. 다만, &ldquo;The Gruntfile"절의 플러그인 명과 task configuration 옵션은 다를 수 있다.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chrome DevTools Revolutions 2013 in korean]]></title>
    <link href="http://zziuni.github.io/blog/2013/10/12/chrome-devtools-revolutions-2013-in-korean/"/>
    <updated>2013-10-12T23:59:00+09:00</updated>
    <id>http://zziuni.github.io/blog/2013/10/12/chrome-devtools-revolutions-2013-in-korean</id>
    <content type="html"><![CDATA[<blockquote><p>이 글은 HTML5Rocks의 <a href="http://www.html5rocks.com/en/tutorials/developertools/revolutions2013/#toc-canvas-profiling">Chrome DevTools Revolutions 2013</a>을 번역한 글입니다.</p></blockquote>

<h2>Introduction <a href="" id="introduction">#</a></h2>

<p>웹 애플리케이션의 복잡도와 기능 증가와 함께 Chrome DevTools도 같이 커졌다. Paul Irish이 이와 관련해서 구글 I/O 2013에서 <a href="https://www.youtube.com/watch?v=x6qe_kVaBpg">Chrome DevTools Revolutions 2013</a>라는 발표를 했다. 웹 앱을 제작하고 테스트하는 방법을 혁신할 수 있는 DevTools의 최신 기능을 볼 수 있다.</p>

<iframe width="560" height="315" src="http://zziuni.github.io//www.youtube.com/embed/x6qe_kVaBpg" frameborder="0" allowfullscreen></iframe>


<p>파울의 발표를 못봤다면 위에있는 동영상을 보자.(기다릴테니 보고오삼.) 아니면 다음 기능 목록으로 건너뛰자.</p>

<ul>
<li>개발용 코드 에디터로 DevTools의 <a href="#workspaces">Workspaces</a>를 사용하자.</li>
<li>Sass를 사용한다면, DevTools에서 Sass(.scss) 파일을 라이브 에디팅하는 기능에 주목하자. 변경사항이 즉시 페이지에 반영된다.</li>
<li>기존에도 안드로이드용 크롬의 페이지를 원격으로 디버깅할 수 있기는 했지만, 이제 <a href="#adb_extension">ADB extension</a>이 안드로이드 기기와의 연결을 담당한다. 그리고 <a href="#reverse_port_forwarding">Reverse port forwarding</a>로 안드로이드 장비에서 여러분의 개발 머신의 localhost로 쉽게 연결하자.</li>
<li>성능은 항상 웹 앱의 주요 관심사다. 그래서 DevTools은 병목현상 추적을 돕는 몇가지 새로운 기능을 추가했다. CPU 프로파일링을 위한 <a href="#flame_chart">Flame Chart</a> 시각화, 렌더링 관련 성능 문제와 사용 메모리을 디버깅하기 위한 <a href="#performance_features">몇가지 새로운 도구</a>를 제공한다.
이 기능들은 크롬 stable 버전 28부터 제공한다.</li>
</ul>


<!-- more -->


<h2>Workspaces <a href="" id="workspaces">#</a></h2>

<p>로컬 웹서버 리소스를 workspaces를 통해서 디스크의 파일로 매핑할 수 있다. 그래서 DevTools의 Source panel에서 모든 타입의 소스를 수정할 수 있고 그 변경사항은 디스크에 반영된다. 반대로 외부 에디터에서 변경해도 즉시 Source panel에 적용된다.</p>

<p>아래 스크린샷은 workspaces의 예제다. 달력 사이트가 localhost에 떠 있고, Sources panel은 로컬 파일 시스템에 있는 이 사이트의 루트 폴더를 보여준다. 이 폴더 안의 파일을 변경하면 디스트에 저장된다. 스크린샷은 아직 저장되지 않은 변경사항이 Calender.css에 있다. 그래서 asterisk(별표)가 파일명 옆에 붙어있다.</p>

<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/552x327xworkspace-sources-panel.png.pagespeed.ic.A9HdSGEKP_.webp" alt="image" /></p>

<p>Control+S 나 Cmmand+S로 디스크에 저장한다.</p>

<p>그리고 Elements panel에서 문서요소의 스타일을 변경하면, Source panel과 외부 에디터에 반영된다. 하지만 다음 사항에 주의하자.</p>

<ul>
<li>DOM은 Elements panel에서 변경해도 저장되지 않는다. 오직 CSS 스타일 변경만 저장된다.</li>
<li>별도 CSS 파일로 정의된 CSS 스타일만 변경할 수 있다. element.style 변경이나 인라인 스타일은 디스크에 저장되지 않는다. 인라인 스타일은 Sources panel에서 변경할 수 있다.</li>
<li>Elements panel에서 CSS 스타일 변경은 바로 저장된다. Control+S나 Command+S를 누를 필요 없다.</li>
</ul>


<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/620x225xworkspace-elements-panel.png.pagespeed.ic.OoXTC47sJz.webp" alt="image" /></p>

<h3>workspace 폴더 추가하기 <a href="" id="add_workspaces_folder">#</a></h3>

<p>workspaces를 사용하려면 두 단계를 거쳐야 한다. DevTools에서 사용할 로컬 폴더의 콘텐츠를 만들고, <a href="#mapping_workspaces_folder">그 폴더를 URL로 매핑</a>한다.</p>

<p>새로운 workspace 폴더를 만들기 위해서는</p>

<ol>
<li>DevTools에서 <strong>Settings</strong>를 클릭.</li>
<li><strong>Workspace</strong> 클릭.</li>
<li><strong>Add Folder</strong> 클릭.</li>
<li>프로젝트 소스 파일들이 있는 폴더를 열어서 <strong>Select</strong> 클릭</li>
<li>경고가 뜨면, DevTools가 폴더 접근을 할 수 있도록 <strong>Allow</strong> 클릭</li>
</ol>


<p>Sources panel에 불러온 소스가 새로운 workspace 폴더로 출력된다. 이제 workspace folder에서 라이브 에디팅을 할 수 있고 그 변경사항은 디스크에 저장된다.</p>

<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/491x198xadded-workspace-folder.png.pagespeed.ic.W_v5Ilwd1n.webp" alt="image" /></p>

<h3>폴더를 URL과 매핑하기 <a href="" id="mapping_workspaces_folder">#</a></h3>

<p>workspace 폴더를 추가한 후에는 그 폴더를 URL에 매핑할 수 있다. 그러면 크롬이 특정 URL을 불러올 때마다 Source panel에서 URL 콘텐츠에 대한 위치로 workspace 폴더 콘텐츠를 출력한다.</p>

<p>workspace 폴더를 URL로 매핑하려면</p>

<ol>
<li>Source panel에서 workspace 폴더의 파일을 오른쪽 클릭하거나 Control+클릭을 한다.</li>
<li><strong>Map to Newwork Resource</strong>를 선택한다.
<img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/415x182xmap-to-resource-menu.png.pagespeed.ic.fFTApZIYmf.webp" alt="image" /></li>
<li>현재 불러온 페이지의 리소스 중에서 일치하는 리소스를 선택하자.
<img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/547x280xselect-resource.png.pagespeed.ic.mAuSXJ7N3I.webp" alt="image" /></li>
<li>크롬에서 해당 페이지를 새로 고침 한다.</li>
</ol>


<p>이렇게 하면, Source panel은 localhost의 소스가 아니라, 여러분의 로컬 workspace 폴더의 콘텐츠를 그냥 바로 보여준다.</p>

<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/462x189xmapped-workspace-folder.png.pagespeed.ic.GQwrmD6ZtB.webp" alt="image" /></p>

<blockquote><p>Note: 여전히 localhost 소스를 바라보고 있다면 크롬을 새로 고침 하자.</p></blockquote>

<p>네트워크 폴더를 workspace 폴더로 연결하는 다른 방법도 있다.</p>

<ul>
<li>network reosurce에서 오른쪽 클릭(Control+클릭)을 하고 <strong>Map to File System Resource</strong>를 선택하자.</li>
<li>DevTools Setting의 Workspace 탭에서 수동으로 매핑을 추가한다.</li>
</ul>


<h2>Sass debugging (experimental) <a href="" id="sass_debugging">#</a></h2>

<p>이 기능을 이용하면 Sources panel에서 Sass(.scss) 파일을 라이브 에디팅 하고 DevTools을 떠나지않고(새로 고침 없이) 바로 결과를 확인할 수 있다. 여러분이 Sass로 생성된 CSS가 반영된 문서요소를 탐색할 때, Elements penel에는 Sass가 생성한 .css가 아니라 .scss 파일이 출력된다.</p>

<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xsass-debugging.png.pagespeed.ic.jGeiBSbVrl.webp" alt="image" /></p>

<p>링크를 클릭하면 Sources panel에 수정 가능한 SCSS 파일이 뜬다. 맘대로 수정 가능.</p>

<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xsass-sources.png.pagespeed.ic.ugimWXRG6A.webp" alt="image" /></p>

<p>DevTools에서든, 별도 에디터에서든 SCSS 파일을 변경해서 저장하면, Sass 컴파일러가 CSS를 재생성한다. 그리고 DevTools는 그 파일을 다시 로드한다.</p>

<blockquote><p>주의: 기술적으로, 이 기능은 소스맵(source map)을 지원하는 모든 CSS 프리프로세서(Less같은)에서 동작해야 하지만 현재는 Sass만 지원한다. 이 기능이 실험단계를 벗어나면, Sass만 지원하는 한계가 없어짐에 따라서 기능명이 바뀔 수 있다.</p></blockquote>

<h3>Sass debugging 사용하기 <a href="" id="using_sass_debugging">#</a></h3>

<p>이 기능을 쓰려면 <a href="http://sass-lang.com/download.html">pre-release verson of the Sass compiler</a>이 필요하다. 이 버전은 현재 소스 맵 생성을 지원하는 유일한 버전이다.</p>

<pre><code>gem install sass -v '&gt;=3.3.0alpha' --pre
</code></pre>

<p>DevTools 실험 기능에서 Sass debugging feature를 활성화해야 한다.</p>

<ol>
<li>크롬에서 <strong>about:flags</strong> 를 연다.</li>
<li><strong>Enable Developer Tools experiments</strong> 를 활성화한다. (한글 버전은 <strong>개발자 도구 실험을 사용합니다</strong>)</li>
<li>크롬 재실행.</li>
<li>DevTools Setting을 열고 <strong>Experiments</strong>를 클릭</li>
<li><strong>Support for Sass</strong> 혹은 <strong>Sass stylesheet debugging</strong>을 활성화한다. (브라우저 버전에 따라 살짝 이름이 다르다.)</li>
</ol>


<p>Sass를 설치하고 나서 Sass 파일 변경을 감지하고 생성된 CSS파일를 위한 소스맵을 생성할 Sass 컴파일러를 실행한다.</p>

<pre><code>sass --watch --sourcemap sass/style.scss:style.css
</code></pre>

<p>Compass를 사용한다면, Sass pre-release 버전이 아직 Compass를 지원하지 않으므로 Sass Debugging과 같이 사용할 수 없다.</p>

<h3>동작방식  <a href="" id="how_it_works">#</a></h3>

<p>개별 SCSS 소스 파일이 처리되는 동안, Sass 컴파일러는 CSS 파일과 함께 <a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">소스 맵</a>파일(.map)을 생성한다. 소스탬 파일은 .scss 파일과 .css 파일의 매핑 정보가 담긴 JSON 파일이다. 각 CSS 파일은 특별한 주석으로 그 안에 자신의 소스맵 파일의 URL을 정의한 힌트를 갖고 있다.</p>

<pre><code>/*# sourceMappingURL=&lt;url&gt;  */
</code></pre>

<p>예를 들어 다음 같은 SCSS 파일이 있다면,</p>

<pre><code>&lt;!-- styles.scss --&gt;
$textSize: 26px;
$fontColor: red;
$bgColor: whitesmoke;

h2 {
    font-size: $textSize;
    color: $fontColor;
    background: $bgColor;
}
</code></pre>

<p>Sass는 sourceMappingURL 주석이 달린 CSS 파일과 생성한다.</p>

<pre><code>&lt;!-- styles.css --&gt;
h2 {
  font-size: 24px;
  color: orange;
  background-color: darkblue;
}
/*# sourceMappingURL=styles.css.map */
</code></pre>

<p>다음은 소스맵 파일 샘플이다.</p>

<pre><code>{
  "version": "3",
  "mappings":"AAKA,EAAG;EACC,SAAS,EANF,IAAI;EAOX,KAAK..."
  "sources": ["sass/styles.scss"],
  "file": "styles.css"
}
</code></pre>

<h2>안드로이드용 크롬 원격 디버깅을 좀 더 쉽게 하기 <a href="" id="remote_debugging">#</a></h2>

<p>셋업을 통해서 좀 더 쉽게 Android의 Chrome을 원격 디버깅할 수 있는 기능이 두 개 추가됐다. <a href="#adb_extension">ADB extension</a>과 <a href="#reverse_port_forwarding">revers port worwarding</a>이다.</p>

<p>ADB extension은 원격 디버깅 설정 과정을 최소화해준다. 장점은 다음과 같다.</p>

<ul>
<li>ADB(Android Debug Bridge)가 내장되어있어서 설치할 필요가 없다.</li>
<li>컴맨드 라인을 사용하지 않아도 된다.</li>
<li>ADB 데몬 시작/종료, 연결된 장비 열람이 엄청나게 쉽다.</li>
</ul>


<p>Reverse port forwarding은 localhost의 서버로 안드로이드용 크롬이 접속하기 쉽게 해준다. 어떤 네트워크 환경은 동일 DNS 트릭이 없으면 접속이 어렵다.</p>

<h3>ADB extension 사용하기 <a href="" id="adb_extension">#</a></h3>

<p>먼저 크롬 웹 스토어에서 <a href="https://chrome.google.com/webstore/detail/adb/dpngiggdglpdnjdoaefidgiigpemgage">ADB Chrome extension</a>을 설치한다. (<strong>Add a Chrome</strong> 클릭)</p>

<blockquote><p>크롬 웹 스토어의 익스텐션 설치는 Window8에서는 안된다. 설치에 문제가 있다면 대안으로 <a href="https://developers.google.com/chrome-developer-tools/docs/remote-debugging">Remote Debugging on Android</a>를 보자.</p></blockquote>

<p>설치 후, 크롬에 회색 처리된 Android 메뉴가 뜬다. ADB를 시작하려면 아이콘을 클릭하고 <strong>Start ADB</strong>를 클릭한다.</p>

<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xadb-menu.png.pagespeed.ic.rCpd-6yJzJ.webp" alt="image" /></p>

<p>ADB가 시작되면, 아이콘이 녹색으로 바뀐다. 그리고 현재 연결된 Android 기기 수가 표시된다.</p>

<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xadb-menu-active.png.pagespeed.ic.QoykBuX1_v.webp" alt="image" /></p>

<p><strong>View Devices</strong>를 클릭하면 연결된 기기와 그 기기의 Chrome 탭들을 보여주는 <strong>about:inspect</strong> 페이지가 뜬다. DevTools에서 그 탭을 깔려면 &ldquo;inspect"를 클릭한다.</p>

<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xabout-inspect.png.pagespeed.ic.IB1dutLTXA.webp" alt="image" /></p>

<p>연결기기가 안 보이면, USB연결이 잘 되어있는지, <strong>USB debugging</strong>이 Android 의 Chrome에 설정되어있는지 확인한다. 자세한 소개와 트러블슈팅은 <a href="https://developers.google.com/chrome-developer-tools/docs/remote-debugging#enable-usb-debugging">Remote Debugging on Android</a>를 참고하자.</p>

<h3>Reverse port forwarding(experimental) <a href="" id="reverse_port_forwarding">#</a></h3>

<p>일반적으로 개발자는 로컬 개발 머신에서 웹 서버를 돌리고, 그 사이트에 Android 장비로 연결하고 싶어한다. 서버와 Android 장비가 동일 네트워크에 있다면 복잡하지 않다. 하지만 사내 네트워크 같은 경우에는 DNS trick을 잘 적용하지 않으면 연결이 불가능한 경우도 있다. 안드로이드용 크롬의 새 기능 중에 이 문제를 간단히 해줄 <em>reverse port forwarding</em>라는 기능이 추가되었다. 이 기능은 USB를 통해서 개발 장비의 특정 포트로 트래픽을 보내는 Android 장비의 TCP 포트 리스링을 생성한다.</p>

<p>이 기능을 사용하기 위해서는</p>

<ul>
<li>개발 장비에 크롬 28이상을 설치한다.</li>
<li>안드로이드 장비에 안드로이드 용 크롬 베타를 설치한다.</li>
<li><a href="http://developer.android.com/tools/help/adb.html">Android Debug Bridge</a> (ADB Chrome extension 아니면 Android SDK 전체)를 개발 PC에 설치한다.</li>
</ul>


<p>revers port forwarding를 사용하려면, <a href="#adb_extension">Using the ADB extension</a>에서 설명한 것 처럼 원격 디버깅을 할 장비가 연결돼야만 한다. 그러고 나서 reverse port forwarding을 활성화하고 여러분의 애플리케이션을 위한 port forwarding 규칙을 추가한다.</p>

<p>먼저 reverse port forwarding을 활성화한다.</p>

<ol>
<li>개발 PC에서 크롬을 실행한다.</li>
<li><strong>about:flags</strong>에서 <strong>Enable Developer Tools experiments</strong>를 활성화하고 크롬을 재실행한다. (한글 버전은 <strong>개발자 도구 실험을 사용합니다</strong>)</li>
<li><strong>about:inspect</strong>를 연다. 그러면 탭 안에 모바일 장비가 보여야 한다.</li>
<li>사이트 목록 우측에 있는 &ldquo;inpect"를 클릭한다.</li>
<li>DevTools 창이 열린다. 거기서 Setting 패널을 연다.</li>
<li>Experiments 를 누르고, <strong>Enable reverse port forwarding</strong>을 클릭한다.</li>
<li>DevTools를 닫고, <strong>about:inspect</strong>로 돌아온다.</li>
</ol>


<p>그러고 나서 port forwarding 규칙을 추가한다.</p>

<ol>
<li>&ldquo;inspect"를 클릭해서 DevTools를 다시 연다. 그리고 다시 Setting으로 들어간다.</li>
<li><strong>Port Forwarding</strong> 탭을 클릭한다.</li>
<li><strong>Devide port</strong> 필드에 Android 장비에서 크롬이 연결해야 할 포트 번호를 입력한다. (기본값은 8080)</li>
<li><strong>Target</strong> 필드에는 여러분의 개발 PC에서 돌고 있는 웹 앱의 포트 번호를 입력한다.</li>
</ol>


<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xport-forwarding.png.pagespeed.ic.10P58COCsE.webp" alt="image" /></p>

<ol>
<li>안드로이드용 크롬에서 <strong>localhost:[device-port-number]</strong>를 열자. [device-port-number]는 <strong>Device port</strong>필드에 입력한 값이다.</li>
</ol>


<p>그러면 개발 장비에서 가져온 콘텐츠가 보여야 한다.</p>

<h2>자바스크립트 프로파일링을 위한 Flame chart 시각화 <a href="" id="flame_chart">#</a></h2>

<p>새로운 Flame chart는 시간 흐름에 따른 Javascript 프로세싱의 시각적 표현을 지원한다. Timeline과 Network panel에서 보아온 것과 유사하다.</p>

<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xflame-chart-1.png.pagespeed.ic.BSC62lh_fA.webp" alt="image" /></p>

<p>가로축은 시간 흐름이고 세로축은 콜 스택(call stack)이다. 패널 위쪽에는 전체 레코딩을 보여주는 오버뷰가 있다. 아래 스크린샷에서 보는 것처럼 마우스로 오버뷰 일부를 선택해서 &ldquo;줌 인"할 수 있다. 하단의 상세 타임라인은 그에 따라 줄어든다.</p>

<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xflame-chart-2.png.pagespeed.ic.1ysnU5qraA.webp" alt="image" /></p>

<p>하단 콜 스택의 상세 뷰는 함수 &ldquo;불록"의 스택을 표현한다. 위쪽에 쌓인 불록은 그 아래쪽 함수 불록이 호출했다. 불록위에 마우스를 올리면 함수명과 타이밍 데이터가 출력된다.</p>

<ul>
<li><strong>Name</strong> &ndash; 함수명</li>
<li><strong>Self time</strong> &ndash; 이 함수의 해당 호출이 완료되는데 걸린 시간. 내부에서 호출하는 다른 함수들을 제외하고 자기 자신만의 실행시간.</li>
<li><strong>Total time</strong> &ndash; 이 함수의 해당 호출이 완료되는데 걸린 시간. 내부에서 호출하는 함수들도 포함한다.</li>
<li><strong>Aggregated self time</strong> &ndash; 레코딩 기간동안 이 함수의 모든 호출에 대한 전체 시간. 이 함수가 호출하는 다른 함수들의 호출 시간은 포함하지 않는다.</li>
<li><strong>Aggregated total time</strong> &ndash; 이 함수의 모든 호출에 대한 전체 시간. 이 함수가 호출하는 다른 함수들의 호출 시간도 모두 포함한다.</li>
</ul>


<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xflame-chart-3.png.pagespeed.ic.t48br1oeBT.webp" alt="image" /></p>

<p>함수 불록을 클릭하면 Sources panel에서 그 함수가 있는 자바스크립트 파일이 열린다. 그리고 그 함수가 정의된 라인으로 이동한다.</p>

<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xflame-chart-sources.png.pagespeed.ic.axKNMB9dbW.webp" alt="image" /></p>

<p>Flame chart를 이용하려면</p>

<ol>
<li>DevTools에서 <strong>Profiles</strong> Panel의 <strong>Profiles</strong> 탭을 선택한다.</li>
<li><strong>Record JavaScript CPU profile</strong>를 선택하고 <strong>Start</strong>를 클릭한다.</li>
<li>데이터 수집이 끝나면, <strong>Stop</strong>를 클릭한다.</li>
<li>profile 뷰에서 <strong>Flame Chart</strong> 시각화를 선택한다.</li>
</ol>


<p><img src="http://www.html5rocks.com/en/tutorials/developertools/revolutions2013/flame-chart-menu.png" alt="image" /></p>

<h2>핵심 성능 측정 도구 다섯가지 <a href="" id="performance_features">#</a></h2>

<p>DevTools에 비약적으로 좋아진 부분은 성능 이슈 조사를 위한 신규 기능들이다.</p>

<ul>
<li>지속적인 페인팅 모드(Continuous painting mode)</li>
<li>사각형과 레이어 페인팅 외곽선 보여주기(Showing Paint rectangles and layer borders)</li>
<li>FPS 계기판(FPS meter)</li>
<li>강제로 동기화되는 레이아웃 찾기(Finding forced synchronous layouts, layout thrashing)</li>
<li>객체 할당 추적하기(Object allocation tracking)</li>
</ul>


<h3>지속적인 페인팅 모드(Continuous painting mode)</h3>

<p>Continuous painting mode는 개별 문서요소나 CSS 스타일의 렌더링 비용 식별을 돕는 DevTools Setting의 옵션이다. (Rendering > Enable Continuous page repainting)</p>

<p>일반적으로, 크롬은 레이아웃이나 스타일이 변경될 때만 화면을 페인팅하며, 이마저도 갱신이 필요한 영역만 한다. 하지만 이 옵션을 활성화 하면, 전체 화면이 계속 리페인팅 된다. 그리고 페이지를 페인팅하기 위해서 크롬이 소비한 시간을 페인팅 회수의 범위와 함께 우측 상단에 보여준다. 그래프는 최근 페인팅 횟수의 분포를 보여주고, 히스토그램을 가로지르는 가로선은 16.6ms 를 나타낸다.</p>

<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xpaint-times.png.pagespeed.ic.4GHJaoT9je.webp" alt="image" /></p>

<p>이 기능은 Elements 패널 안에서 DOM 트리를 돌아다니며 개별 문서요소를 숨기거나(현재 선택된 문서요소를 숨기려면 H를 누르면 된다.), 아니면 문서요소의 CSS 스타일을 비활성화할 때 효과를 볼 수 있다. 이런 식으로 한 문서요소나 스타일이 페이지 렌더링에 얼마나 부하를 주는지 볼 수 있다. 만약 렌더링 비용이 있다면, 페이지 페인트 회수가 변경돼서 우측 상단에 출력된다. 단일 문서요소를 숨겼는데, 페인팅 회수를 크게 줄었다면, 여러분은 그 문서요소의 구조나 스타일 개선에 집중해야 한다.</p>

<p>Continuous painting mode를 활성화하려면</p>

<ol>
<li>DevTools Setting을 연다.</li>
<li><strong>General</strong> 탭에서 <strong>Rendering</strong>아래에 <strong>Enable continuous page repainting</strong>을 활성화한다.</li>
</ol>


<blockquote><p>만약 이 옵션이 안 보이면, <strong>about:flags</strong>에 들어가서, <strong>GPU compositing on all pages</strong>를 활성화하고 크롬을 재실행한다.</p></blockquote>

<p>더 자세한 정보는 <a href="http://updates.html5rocks.com/2013/02/Profiling-Long-Paint-Times-with-DevTools-Continuous-Painting-Mode">Profiling Long Paint Times with DevTools' Continuous Painting Mode</a>를 참고하자.</p>

<h3>사각형과 레이어 페인팅 외곽선 보여주기()Showing paint rectangles and layer borders)</h3>

<p>화면에서 페인팅 되고 있는 사각형 영역을 시각적으로 보여주는 옵션이다. (Setting > Rendering > Show paint rectangles). 예를 들어, 아래 스크린샷은 CSS 호버 효과가 적용되는 영역을 빨간색 사각형으로 보여주고 있다. 이 정도는 화면대비 작은 영역이라 괜찮다.</p>

<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/paint-rect-1.png.pagespeed.ce.9c4qALXuVJ.png" alt="image" /></p>

<p>개발자는 전체 화면의 리페인팅을 일으키는 디자인이나 개발은 피하기를 원한다. 예를 들어, 다음 스크린샷을 보면, 사용자는 페이지를 스크롤하는 중이다. 페인팅 사각형 하나가 스크롤바를 감싸고 있고, 남은 페이지 영역 전체를 다른 페인팅 사각형이 감싸고 있다. 이 경우 이렇게 되는 원인은 Body의 배경 이미지다. 이미지 위치가 CSS에서 fixed로 지정되어있어서 스크롤마다 전체 페이지를 리페인팅 시킨다.</p>

<p><img src="http://www.html5rocks.com/en/tutorials/developertools/revolutions2013/paint-rect-2.png" alt="image" /></p>

<h3>FPS 계기판(FPS meter)</h3>

<p><strong>FPS meter</strong>는 페이지의 현재 초당 프레임율, 최대/최소 프레임율, 시간당 프레임율을 보여주는 막대 그래프와 프레임율 변화를 보여주는 히스토그램을 출력한다.</p>

<p><img src="http://www.html5rocks.com/en/tutorials/developertools/revolutions2013/fps-meter.png" alt="image" /></p>

<p>FPS 계기판을 보려면</p>

<ol>
<li>DevTools Settings를 연다.</li>
<li><strong>General</strong>를 클릭한다.</li>
<li><strong>Rendering</strong> 아래에, <strong>Force accelerated compositing</strong>과 <strong>Show FPS meter</strong>를 활성화한다.</li>
</ol>


<p><strong>about:flag</strong>에서 <strong>FPS counter</strong>를 활성화하고 크롬을 재실행하면, FPS 계기판을 상항 보이게 할 수 있다.</p>

<h3>강제로 동기화 되는 레이아웃 찾기(Finding forced synchronous layouts(layout thrashing))</h3>

<p>렌더링 성능을 최대화하기 위해서, 크롬은 보통 애플리케이션이 요청하는 레이아웃 변경들을 한 번에 적용한다. 그리고 변경 요청을 비동기로 계산하고 렌더링할 레이아웃 전달 스케줄을 잡는다. 하지만 애플리케이션이 레이아웃 관련 프로퍼티를 요청하면(offsetHeight, offsetWidth같은), 크롬은 즉시 강제로 동기화시켜 페이지 레이아웃을 적용한다. 이를 <em>forced synchronous layouts</em>이라 부르는데, 이 현상은 중요한 렌더링 성능 저하를 가져올 수 있다. 특히 거대한 DOM 트리가 반복해서 적용될 때, 이를 &ldquo;layout thrashing"라고 부른다.</p>

<p>Timeline panel에서 녹화를 하면, 관련 녹화물 옆에 노란색 경고 아이콘(<img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xwarning-icon.png.pagespeed.ic.kIYn6LmPe4.webp" alt="image" />)으로 forced synchronous layouts를 찾아서 알려준다. 그 녹화물에 마우스를 올리면 무효화된 레이아웃(invalidated layout)의 코드와 강요된 레이아웃(forced layout)의 코드에 대한 스택 트레이스가 출력된다.</p>

<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xforced-sync-layout-popup.png.pagespeed.ic.fvGqEI6wkY.webp" alt="image" /></p>

<p>그리고 이 팝업은 레이아웃을 잡는 데 필요한 노드 수(nodes that need layout), 레이아웃을 다시 한 트리의 사이즈(layout tree size), 레이아웃의 유효범위(layout scope), 레이아웃 루트(layout root)도 같이 보여준다.</p>

<p>더 자세한 정보는  <a href="https://developers.google.com/chrome-developer-tools/docs/demos/too-much-layout/">Timeline demo: Diagnosing forced synchronous layouts</a>를 보자.</p>

<h3>객체 할당 트랙킹(Object allocation tracking)</h3>

<p>Object allocation tracking은 시간별 할당을 보여주는 메모리 프로파일의 새로운 형태다. allocation tracking을 시작하면, DevTools은 시간별로 연속적으로 스냅샷을 쌓는다. allocation 프로파일은 객체가 어디서 생성되고 있는지, 어디서 참조되고 있는지를 보여준다.</p>

<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xallocation-tracker.png.pagespeed.ic.ejjMDH2Qku.webp" alt="image" /></p>

<p>track object allocations를 사용하려면</p>

<ol>
<li>DevTools에서 <strong>Profiles</strong> 탭을 클릭한다.</li>
<li><strong>Record heap allocations</strong>을 선택하고 <strong>Start</strong> 클릭한다.</li>
<li>데이터 수집을 끝냈으면, <strong>Stop recording heap profile</strong>을 클릭한다. (해당 패널 좌측 하단의 빨간 원 아이콘)</li>
</ol>


<h2>Canvas profiling (experimental)</h2>

<p>끝으로 아직 실험적인 기능인 Cavas profile은 canvas 문서요소에 만들어진 WebGL 호출을 녹화하고 재생한다. 개별 WebGL 호출을 관통하며 단계별로 진행해보고 렌더링된 결과를 볼 수 있다. 특별한 호출을 재실행하는 순간을 볼 수 있다.</p>

<p>canvas profile을 사용하려면</p>

<ol>
<li>DevTools setting의 <strong>Experiments</strong>안에 <strong>Canvas profiling</strong>을 활성화한다. (Experiments 탭이 보이지 않으면, <strong>about:flags</strong>에서 <strong>Enable Developer Tools experiments</strong>를 활성화하고 크롬을 재실행한다. 한글 버전은 <strong>개발자 도구 실험을 사용합니다</strong>)</li>
<li><strong>Profiles</strong> panel을 클릭한다.</li>
<li><strong>Capture canvas frame</strong>을 선택하고 <strong>Take snapshot</strong>을 클릭한다.</li>
<li>이제 canvas 프레임을 생성하는데 사용된 호출을 탐색할 수 있다.</li>
</ol>


<p><img src="http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/canvas-profile.png.pagespeed.ce.vmnLpLctAQ.png" alt="image" /></p>
]]></content>
  </entry>
  
</feed>
